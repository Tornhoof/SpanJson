<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(Single),
        typeof(Double),
        typeof(decimal),
        typeof(bool),
        typeof(char),
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(TimeSpan),
        typeof(Guid),
        typeof(string),
        typeof(Version),
        typeof(Uri)
    };
    var minMaxValueTypes = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(char),
    };
    var overflowNumTypes = new []
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
    };
    var escapeTestTypes = new []
    {
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(TimeSpan),
        typeof(Guid),
    };
#>
using System;
using System.Collections.Generic;
using SpanJson;
using SpanJson.Tests;
using Xunit;
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Tests.Generated
{
<# foreach(var t in types) {  #>
<# if(t.IsValueType) { #>
    public partial class Nullable<#= t.Name #>ListTests : NullableListTestBase<<#= t.Name #>>
    {
    }

    public partial class Nullable<#= t.Name #>ArrayTests : NullableArrayTestBase<<#= t.Name #>>
    {
    }
    public partial class <#= t.Name #>Tests : StructTestBase<<#= t.Name #>>
    {
<#  if(minMaxValueTypes.Contains(t)) {#>
        [Theory]
        [InlineData(<#= t.Name #>.MinValue)]
        [InlineData(<#= t.Name #>.MaxValue)]
        public void SerializeDeserializeMinMaxUtf8(<#= t.Name #> input)
        {
            var serialized = JsonSerializer.Generic.Utf8.Serialize(input);
            var deserialized = JsonSerializer.Generic.Utf8.Deserialize<<#= t.Name #>>(serialized);
            Assert.Equal(input, deserialized);
        }

        [Theory]
        [InlineData(<#= t.Name #>.MinValue)]
        [InlineData(<#= t.Name #>.MaxValue)]
        public void SerializeDeserializeMinMaxUtf16(<#= t.Name #> input)
        {
            var serialized = JsonSerializer.Generic.Utf16.Serialize(input);
            var deserialized = JsonSerializer.Generic.Utf16.Deserialize<<#= t.Name #>>(serialized);
            Assert.Equal(input, deserialized);
        }
<# } #>
<#  if(overflowNumTypes.Contains(t)) {#>

        [Fact]
        public void SerializeDeserializeOverflowUtf8()
        {
            var serialized = JsonSerializer.Generic.Utf8.Serialize(ulong.MaxValue);
            Assert.Throws<OverflowException>( () => JsonSerializer.Generic.Utf8.Deserialize<<#= t.Name #>>(serialized));
        }

        [Fact]
        public void SerializeDeserializeOverflowUtf16()
        {
            var serialized = JsonSerializer.Generic.Utf16.Serialize(ulong.MaxValue);
            Assert.Throws<OverflowException>( () => JsonSerializer.Generic.Utf16.Deserialize<<#= t.Name #>>(serialized));
        }
<# } #>

        [Fact]
        public void PrimitiveWrapperUtf8()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<byte>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToByteArray();

            var reader = new JsonReader<byte>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }

        [Fact]
        public void PrimitiveWrapperUtf16()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<char>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToString();

            var reader = new JsonReader<char>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }
<#  if(escapeTestTypes.Contains(t)) {#>

        [Fact]
        public void EscapedUtf8()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<byte>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToByteArray();
            output = EscapeMore(output);
            var reader = new JsonReader<byte>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }

        [Fact]
        public void EscapedUtf16()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<char>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToString();
            output = EscapeMore(output);
            var reader = new JsonReader<char>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }
<# } #>
    }
<# } #>
<# if(!t.IsValueType) { #>
    public partial class <#= t.Name #>Tests : ClassTestBase<<#= t.Name #>>
    {
        [Fact]
        public void PrimitiveWrapperUtf8()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<byte>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToByteArray();

            var reader = new JsonReader<byte>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }

        [Fact]
        public void PrimitiveWrapperUtf16()
        {
            var value = Fixture.Create<<#= t.Name #>>();
            var writer = new JsonWriter<char>();
            writer.Write<#= t.Name #>(value);
            var output = writer.ToString();

            var reader = new JsonReader<char>(output);
            var deserialized = reader.Read<#= t.Name #>();
            Assert.Equal(value, deserialized);
        }
    }
<# } #>
    public partial class <#= t.Name #>ListTests : ListTestBase<<#= t.Name #>>
    {
    }

    public partial class <#= t.Name #>ArrayTests : ArrayTestBase<<#= t.Name #>>
    {
    }
<# } #>
}