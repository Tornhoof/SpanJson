<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte), 
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
    };
#>
using System;
using Xunit;
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable InconsistentNaming
namespace SpanJson.Tests
{
    public class EnumFlagsTests
    {
<# foreach(var t in types) {  #>
		
		[Flags]
		public enum <#= t.Name#>Enum : <#= t.Name #>
		{
			MinValue = <#= t.Name #>.MinValue,
			Two = 2,
			Four = 4,
			Eight = 8,
			MaxValue = <#= t.Name #>.MaxValue
		}


        [Theory]
        [InlineData(<#= t.Name #>Enum.MinValue)]
        [InlineData(<#= t.Name #>Enum.MaxValue)]
<# if(Convert.ToBoolean(t.GetField("MinValue").GetValue(null))) {  #>
        [InlineData(<#= t.Name #>Enum.MinValue | <#= t.Name #>Enum.MaxValue)]
<# } #>
		[InlineData(<#= t.Name #>Enum.Two)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four | <#= t.Name #>Enum.Eight)]
        public void SerializeDeserialize<#= t.Name#>EnumUtf8(<#= t.Name #>Enum input)
        {
            var serialized = JsonSerializer.Generic.Utf8.Serialize(input);
            var deserialized = JsonSerializer.Generic.Utf8.Deserialize<<#= t.Name #>Enum>(serialized);
            Assert.Equal(input, deserialized);
        }

        [Theory]
        [InlineData(<#= t.Name #>Enum.MinValue)]
        [InlineData(<#= t.Name #>Enum.MaxValue)]
<# if(Convert.ToBoolean(t.GetField("MinValue").GetValue(null))) {  #>
        [InlineData(<#= t.Name #>Enum.MinValue | <#= t.Name #>Enum.MaxValue)]
<# } #>
		[InlineData(<#= t.Name #>Enum.Two)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four | <#= t.Name #>Enum.Eight)]
        public void SerializeDeserialize<#= t.Name#>EnumUtf16(<#= t.Name #>Enum input)
        {
            var serialized = JsonSerializer.Generic.Utf16.Serialize(input);
            var deserialized = JsonSerializer.Generic.Utf16.Deserialize<<#= t.Name #>Enum>(serialized);
            Assert.Equal(input, deserialized);
        }

        [Theory]
        [InlineData(<#= t.Name #>Enum.MinValue)]
        [InlineData(<#= t.Name #>Enum.MaxValue)]
<# if(Convert.ToBoolean(t.GetField("MinValue").GetValue(null))) {  #>
        [InlineData(<#= t.Name #>Enum.MinValue | <#= t.Name #>Enum.MaxValue)]
<# } #>
		[InlineData(<#= t.Name #>Enum.Two)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four | <#= t.Name #>Enum.Eight)]
        public void SerializeDeserializeInteger<#= t.Name#>EnumUtf8(<#= t.Name #>Enum input)
        {
            var serialized = JsonSerializer.Generic.Utf8.Serialize<<#= t.Name #>Enum, ExcludeNullCamelCaseIntegerEnumResolver<byte>>(input);
            var deserialized = JsonSerializer.Generic.Utf8.Deserialize<<#= t.Name #>Enum, ExcludeNullCamelCaseIntegerEnumResolver<byte>>(serialized);
            Assert.Equal(input, deserialized);
        }

        [Theory]
        [InlineData(<#= t.Name #>Enum.MinValue)]
        [InlineData(<#= t.Name #>Enum.MaxValue)]
<# if(Convert.ToBoolean(t.GetField("MinValue").GetValue(null))) {  #>
        [InlineData(<#= t.Name #>Enum.MinValue | <#= t.Name #>Enum.MaxValue)]
<# } #>
		[InlineData(<#= t.Name #>Enum.Two)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four)]
		[InlineData(<#= t.Name #>Enum.Two | <#= t.Name #>Enum.Four | <#= t.Name #>Enum.Eight)]
        public void SerializeDeserializeInteger<#= t.Name#>EnumUtf16(<#= t.Name #>Enum input)
        {
            var serialized = JsonSerializer.Generic.Utf16.Serialize<<#= t.Name #>Enum, ExcludeNullCamelCaseIntegerEnumResolver<char>>(input);
            var deserialized = JsonSerializer.Generic.Utf16.Deserialize<<#= t.Name #>Enum, ExcludeNullCamelCaseIntegerEnumResolver<char>>(serialized);
            Assert.Equal(input, deserialized);
        }
<# } #>
    }
}