<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System" #>
<#@ Assembly name="$(TargetPath)" #>
<#@ Assembly name="$(SolutionDir)\SpanJson.Shared\bin\Debug\netstandard2.0\SpanJson.Shared.dll" #>
<#
    var serializers = new []
    {
        new {ResultType = typeof(string), Name = "JilSerializer"},
        new {ResultType = typeof(string), Name = "SpanJsonSerializer"},
        new {ResultType = typeof(byte[]), Name = "SpanJsonUtf8Serializer"},
        new {ResultType = typeof(byte[]), Name = "Utf8JsonSerializer"},
    };
    var models = typeof(SpanJson.Shared.Models.AccessToken).Assembly
                .GetTypes()
                .Where(t => t.Namespace.Contains("Models") && !t.IsEnum && !t.IsInterface && !t.IsAbstract)
                .ToList();
#>
using System;
using BenchmarkDotNet.Attributes;
using SpanJson.Benchmarks.Serializers;
using SpanJson.Shared.Fixture;

namespace SpanJson.Benchmarks
{
  // Autogenerated
  // ReSharper disable BuiltInTypeReferenceStyle
  [Config(typeof(MyConfig))]
  public partial class ModelBenchmark
  {
    private static readonly ExpressionTreeFixture ExpressionTreeFixture = new ExpressionTreeFixture();
<#
    foreach(var serializer in serializers)
    {
#>
    private static readonly <#= serializer.Name #> <#= serializer.Name #> = new <#= serializer.Name #>();
<#
    }
#>
<#
    foreach(var model in models)
    {
        var fullNameFixed = model.FullName.Replace('+','.');
#>
    private static readonly <#= fullNameFixed #> <#= model.Name #>Input = ExpressionTreeFixture.Create<<#= fullNameFixed #>>();
<#
    }
#>
<#
    foreach(var model in models)
    {
        var fullNameFixed = model.FullName.Replace('+','.');
    foreach(var serializer in serializers)
    {
        var resultType = serializer.ResultType;
#>

    [Benchmark]
    public <#= resultType.FullName #> Serialize<#= model.Name #>With<#= serializer.Name #>()
    {
        return <#= serializer.Name #>.Serialize(<#= model.Name #>Input);
    }
<#
    }
    }
#>
<#
    foreach(var model in models)
    {
        var fullNameFixed = model.FullName.Replace('+','.');
    foreach(var serializer in serializers)
    {
        var resultType = serializer.ResultType;
#>
    private static readonly <#= resultType.Name#> <#= model.Name #>OutputOf<#= serializer.Name #> = <#= serializer.Name #>.Serialize(<#= model.Name #>Input);
    [Benchmark]
    public <#= fullNameFixed #> Deserialize<#= model.Name #>With<#= serializer.Name #>()
    {
        return <#= serializer.Name #>.Deserialize<<#= fullNameFixed #>>(<#= model.Name #>OutputOf<#= serializer.Name #>);
    }
<#
    }
    }
#>
  }
}
