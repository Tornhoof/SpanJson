<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System" #>
<#
    var serializers = new []
    {
        new {ResultType = typeof(string), Name = "JilSerializer"},
        new {ResultType = typeof(string), Name = "SpanJsonSerializer"},
        new {ResultType = typeof(byte[]), Name = "SpanJsonUtf8Serializer"},
        new {ResultType = typeof(byte[]), Name = "Utf8JsonSerializer"},
    };
    var bclTypes = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(Single),
        typeof(Double),
        typeof(bool),
        typeof(char),
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(TimeSpan),
        typeof(Guid),
        typeof(string),
        typeof(decimal),
        typeof(Version),
        typeof(Uri)
    };
#>
using System;
using BenchmarkDotNet.Attributes;
using SpanJson.Benchmarks.Serializers;
using SpanJson.Shared.Fixture;
namespace SpanJson.Benchmarks
{
  // Autogenerated
  // ReSharper disable BuiltInTypeReferenceStyle
  [Config(typeof(MyConfig))]
  public class BclBenchmark
  {
    private static readonly ExpressionTreeFixture ExpressionTreeFixture = new ExpressionTreeFixture();
<#
    foreach(var serializer in serializers)
    {
#>
    private static readonly <#= serializer.Name #> <#= serializer.Name #> = new <#= serializer.Name #>();
<#
    }
#>
<#
    foreach(var model in bclTypes)
    {
#>
    private static readonly <#= model.Name #> <#= model.Name #>Input = ExpressionTreeFixture.Create<<#= model.Name #>>();
<#
    }
#>
<#
    foreach(var model in bclTypes)
    {
    foreach(var serializer in serializers)
    {
#>

    [Benchmark]
    public <#= serializer.ResultType.Name #> Serialize<#= model.Name #>With<#= serializer.Name #>()
    {
        return <#= serializer.Name #>.Serialize(<#= model.Name #>Input);
    }
<#
    }
    }
#>
<#
    foreach(var model in bclTypes)
    {
    foreach(var serializer in serializers)
    {
#>
    private static readonly <#= serializer.ResultType.Name#> <#= model.Name #>OutputOf<#= serializer.Name #> = <#= serializer.Name #>.Serialize(<#= model.Name #>Input);
    [Benchmark]
    public <#= model.Name #> Deserialize<#= model.Name #>With<#= serializer.Name #>()
    {
        return <#= serializer.Name #>.Deserialize<<#= model.Name #>>(<#= model.Name #>OutputOf<#= serializer.Name #>);
    }
<#
    }
    }
#>
  }
}
