using System;
using System.Buffers;
using System.Collections.Generic;
using SpanJson.Helpers;

// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters
{
    public sealed class SByteUtf16Formatter<TResolver> : IJsonFormatter<SByte, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SByteUtf16Formatter<TResolver> Default = new SByteUtf16Formatter<TResolver>();

        public SByte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16SByte();
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte value, int nestingLimit)
        {
            writer.WriteUtf16SByte(value);
        }
    }

    public sealed class NullableSByteUtf16Formatter<TResolver> : IJsonFormatter<SByte?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSByteUtf16Formatter<TResolver> Default = new NullableSByteUtf16Formatter<TResolver>();
        private static readonly SByteUtf16Formatter<TResolver> ElementFormatter = SByteUtf16Formatter<TResolver>.Default;

        public SByte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableSByteUtf16ArrayFormatter<TResolver> : IJsonFormatter<SByte?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSByteUtf16ArrayFormatter<TResolver> Default = new NullableSByteUtf16ArrayFormatter<TResolver>();
        private static readonly NullableSByteUtf16Formatter<TResolver> ElementFormatter = NullableSByteUtf16Formatter<TResolver>.Default;

        public SByte?[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = new SByte?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableSByteUtf16ListFormatter<TResolver> : IJsonFormatter<List<SByte?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSByteUtf16ListFormatter<TResolver> Default = new NullableSByteUtf16ListFormatter<TResolver>();
        private static readonly NullableSByteUtf16Formatter<TResolver> ElementFormatter = NullableSByteUtf16Formatter<TResolver>.Default;

        public List<SByte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<SByte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf16ArrayFormatter<TResolver> : IJsonFormatter<SByte[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SByteUtf16ArrayFormatter<TResolver> Default = new SByteUtf16ArrayFormatter<TResolver>();
        private static readonly SByteUtf16Formatter<TResolver> ElementFormatter = SByteUtf16Formatter<TResolver>.Default;

        public SByte[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = new SByte[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf16ListFormatter<TResolver> : IJsonFormatter<List<SByte>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SByteUtf16ListFormatter<TResolver> Default = new SByteUtf16ListFormatter<TResolver>();
        private static readonly SByteUtf16Formatter<TResolver> ElementFormatter = SByteUtf16Formatter<TResolver>.Default;

        public List<SByte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<SByte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf8Formatter<TResolver> : IJsonFormatter<SByte, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SByteUtf8Formatter<TResolver> Default = new SByteUtf8Formatter<TResolver>();

        public SByte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8SByte();
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte value, int nestingLimit)
        {
            writer.WriteUtf8SByte(value);
        }
    }

    public sealed class NullableSByteUtf8Formatter<TResolver> : IJsonFormatter<SByte?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSByteUtf8Formatter<TResolver> Default = new NullableSByteUtf8Formatter<TResolver>();
        private static readonly SByteUtf8Formatter<TResolver> ElementFormatter = SByteUtf8Formatter<TResolver>.Default;

        public SByte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableSByteUtf8ArrayFormatter<TResolver> : IJsonFormatter<SByte?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSByteUtf8ArrayFormatter<TResolver> Default = new NullableSByteUtf8ArrayFormatter<TResolver>();
        private static readonly NullableSByteUtf8Formatter<TResolver> ElementFormatter = NullableSByteUtf8Formatter<TResolver>.Default;

        public SByte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = new SByte?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableSByteUtf8ListFormatter<TResolver> : IJsonFormatter<List<SByte?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSByteUtf8ListFormatter<TResolver> Default = new NullableSByteUtf8ListFormatter<TResolver>();
        private static readonly NullableSByteUtf8Formatter<TResolver> ElementFormatter = NullableSByteUtf8Formatter<TResolver>.Default;

        public List<SByte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SByteUtf8ArrayFormatter<TResolver> : IJsonFormatter<SByte[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SByteUtf8ArrayFormatter<TResolver> Default = new SByteUtf8ArrayFormatter<TResolver>();
        private static readonly SByteUtf8Formatter<TResolver> ElementFormatter = SByteUtf8Formatter<TResolver>.Default;

        public SByte[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = new SByte[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SByteUtf8ListFormatter<TResolver> : IJsonFormatter<List<SByte>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SByteUtf8ListFormatter<TResolver> Default = new SByteUtf8ListFormatter<TResolver>();
        private static readonly SByteUtf8Formatter<TResolver> ElementFormatter = SByteUtf8Formatter<TResolver>.Default;

        public List<SByte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf16Formatter<TResolver> : IJsonFormatter<Int16, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int16Utf16Formatter<TResolver> Default = new Int16Utf16Formatter<TResolver>();

        public Int16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int16();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16 value, int nestingLimit)
        {
            writer.WriteUtf16Int16(value);
        }
    }

    public sealed class NullableInt16Utf16Formatter<TResolver> : IJsonFormatter<Int16?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt16Utf16Formatter<TResolver> Default = new NullableInt16Utf16Formatter<TResolver>();
        private static readonly Int16Utf16Formatter<TResolver> ElementFormatter = Int16Utf16Formatter<TResolver>.Default;

        public Int16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt16Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int16?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt16Utf16ArrayFormatter<TResolver> Default = new NullableInt16Utf16ArrayFormatter<TResolver>();
        private static readonly NullableInt16Utf16Formatter<TResolver> ElementFormatter = NullableInt16Utf16Formatter<TResolver>.Default;

        public Int16?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = new Int16?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt16Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int16?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt16Utf16ListFormatter<TResolver> Default = new NullableInt16Utf16ListFormatter<TResolver>();
        private static readonly NullableInt16Utf16Formatter<TResolver> ElementFormatter = NullableInt16Utf16Formatter<TResolver>.Default;

        public List<Int16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int16[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int16Utf16ArrayFormatter<TResolver> Default = new Int16Utf16ArrayFormatter<TResolver>();
        private static readonly Int16Utf16Formatter<TResolver> ElementFormatter = Int16Utf16Formatter<TResolver>.Default;

        public Int16[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = new Int16[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int16>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int16Utf16ListFormatter<TResolver> Default = new Int16Utf16ListFormatter<TResolver>();
        private static readonly Int16Utf16Formatter<TResolver> ElementFormatter = Int16Utf16Formatter<TResolver>.Default;

        public List<Int16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf8Formatter<TResolver> : IJsonFormatter<Int16, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int16Utf8Formatter<TResolver> Default = new Int16Utf8Formatter<TResolver>();

        public Int16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int16();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16 value, int nestingLimit)
        {
            writer.WriteUtf8Int16(value);
        }
    }

    public sealed class NullableInt16Utf8Formatter<TResolver> : IJsonFormatter<Int16?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt16Utf8Formatter<TResolver> Default = new NullableInt16Utf8Formatter<TResolver>();
        private static readonly Int16Utf8Formatter<TResolver> ElementFormatter = Int16Utf8Formatter<TResolver>.Default;

        public Int16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt16Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int16?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt16Utf8ArrayFormatter<TResolver> Default = new NullableInt16Utf8ArrayFormatter<TResolver>();
        private static readonly NullableInt16Utf8Formatter<TResolver> ElementFormatter = NullableInt16Utf8Formatter<TResolver>.Default;

        public Int16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = new Int16?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt16Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int16?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt16Utf8ListFormatter<TResolver> Default = new NullableInt16Utf8ListFormatter<TResolver>();
        private static readonly NullableInt16Utf8Formatter<TResolver> ElementFormatter = NullableInt16Utf8Formatter<TResolver>.Default;

        public List<Int16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int16[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int16Utf8ArrayFormatter<TResolver> Default = new Int16Utf8ArrayFormatter<TResolver>();
        private static readonly Int16Utf8Formatter<TResolver> ElementFormatter = Int16Utf8Formatter<TResolver>.Default;

        public Int16[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = new Int16[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int16>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int16Utf8ListFormatter<TResolver> Default = new Int16Utf8ListFormatter<TResolver>();
        private static readonly Int16Utf8Formatter<TResolver> ElementFormatter = Int16Utf8Formatter<TResolver>.Default;

        public List<Int16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf16Formatter<TResolver> : IJsonFormatter<Int32, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int32Utf16Formatter<TResolver> Default = new Int32Utf16Formatter<TResolver>();

        public Int32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int32();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32 value, int nestingLimit)
        {
            writer.WriteUtf16Int32(value);
        }
    }

    public sealed class NullableInt32Utf16Formatter<TResolver> : IJsonFormatter<Int32?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt32Utf16Formatter<TResolver> Default = new NullableInt32Utf16Formatter<TResolver>();
        private static readonly Int32Utf16Formatter<TResolver> ElementFormatter = Int32Utf16Formatter<TResolver>.Default;

        public Int32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt32Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int32?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt32Utf16ArrayFormatter<TResolver> Default = new NullableInt32Utf16ArrayFormatter<TResolver>();
        private static readonly NullableInt32Utf16Formatter<TResolver> ElementFormatter = NullableInt32Utf16Formatter<TResolver>.Default;

        public Int32?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = new Int32?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt32Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int32?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt32Utf16ListFormatter<TResolver> Default = new NullableInt32Utf16ListFormatter<TResolver>();
        private static readonly NullableInt32Utf16Formatter<TResolver> ElementFormatter = NullableInt32Utf16Formatter<TResolver>.Default;

        public List<Int32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int32[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int32Utf16ArrayFormatter<TResolver> Default = new Int32Utf16ArrayFormatter<TResolver>();
        private static readonly Int32Utf16Formatter<TResolver> ElementFormatter = Int32Utf16Formatter<TResolver>.Default;

        public Int32[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = new Int32[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int32>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int32Utf16ListFormatter<TResolver> Default = new Int32Utf16ListFormatter<TResolver>();
        private static readonly Int32Utf16Formatter<TResolver> ElementFormatter = Int32Utf16Formatter<TResolver>.Default;

        public List<Int32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf8Formatter<TResolver> : IJsonFormatter<Int32, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int32Utf8Formatter<TResolver> Default = new Int32Utf8Formatter<TResolver>();

        public Int32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int32();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32 value, int nestingLimit)
        {
            writer.WriteUtf8Int32(value);
        }
    }

    public sealed class NullableInt32Utf8Formatter<TResolver> : IJsonFormatter<Int32?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt32Utf8Formatter<TResolver> Default = new NullableInt32Utf8Formatter<TResolver>();
        private static readonly Int32Utf8Formatter<TResolver> ElementFormatter = Int32Utf8Formatter<TResolver>.Default;

        public Int32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt32Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int32?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt32Utf8ArrayFormatter<TResolver> Default = new NullableInt32Utf8ArrayFormatter<TResolver>();
        private static readonly NullableInt32Utf8Formatter<TResolver> ElementFormatter = NullableInt32Utf8Formatter<TResolver>.Default;

        public Int32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = new Int32?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt32Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int32?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt32Utf8ListFormatter<TResolver> Default = new NullableInt32Utf8ListFormatter<TResolver>();
        private static readonly NullableInt32Utf8Formatter<TResolver> ElementFormatter = NullableInt32Utf8Formatter<TResolver>.Default;

        public List<Int32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int32[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int32Utf8ArrayFormatter<TResolver> Default = new Int32Utf8ArrayFormatter<TResolver>();
        private static readonly Int32Utf8Formatter<TResolver> ElementFormatter = Int32Utf8Formatter<TResolver>.Default;

        public Int32[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = new Int32[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int32>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int32Utf8ListFormatter<TResolver> Default = new Int32Utf8ListFormatter<TResolver>();
        private static readonly Int32Utf8Formatter<TResolver> ElementFormatter = Int32Utf8Formatter<TResolver>.Default;

        public List<Int32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf16Formatter<TResolver> : IJsonFormatter<Int64, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int64Utf16Formatter<TResolver> Default = new Int64Utf16Formatter<TResolver>();

        public Int64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int64();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64 value, int nestingLimit)
        {
            writer.WriteUtf16Int64(value);
        }
    }

    public sealed class NullableInt64Utf16Formatter<TResolver> : IJsonFormatter<Int64?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt64Utf16Formatter<TResolver> Default = new NullableInt64Utf16Formatter<TResolver>();
        private static readonly Int64Utf16Formatter<TResolver> ElementFormatter = Int64Utf16Formatter<TResolver>.Default;

        public Int64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt64Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int64?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt64Utf16ArrayFormatter<TResolver> Default = new NullableInt64Utf16ArrayFormatter<TResolver>();
        private static readonly NullableInt64Utf16Formatter<TResolver> ElementFormatter = NullableInt64Utf16Formatter<TResolver>.Default;

        public Int64?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = new Int64?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt64Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int64?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableInt64Utf16ListFormatter<TResolver> Default = new NullableInt64Utf16ListFormatter<TResolver>();
        private static readonly NullableInt64Utf16Formatter<TResolver> ElementFormatter = NullableInt64Utf16Formatter<TResolver>.Default;

        public List<Int64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf16ArrayFormatter<TResolver> : IJsonFormatter<Int64[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int64Utf16ArrayFormatter<TResolver> Default = new Int64Utf16ArrayFormatter<TResolver>();
        private static readonly Int64Utf16Formatter<TResolver> ElementFormatter = Int64Utf16Formatter<TResolver>.Default;

        public Int64[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = new Int64[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf16ListFormatter<TResolver> : IJsonFormatter<List<Int64>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly Int64Utf16ListFormatter<TResolver> Default = new Int64Utf16ListFormatter<TResolver>();
        private static readonly Int64Utf16Formatter<TResolver> ElementFormatter = Int64Utf16Formatter<TResolver>.Default;

        public List<Int64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf8Formatter<TResolver> : IJsonFormatter<Int64, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int64Utf8Formatter<TResolver> Default = new Int64Utf8Formatter<TResolver>();

        public Int64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int64();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64 value, int nestingLimit)
        {
            writer.WriteUtf8Int64(value);
        }
    }

    public sealed class NullableInt64Utf8Formatter<TResolver> : IJsonFormatter<Int64?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt64Utf8Formatter<TResolver> Default = new NullableInt64Utf8Formatter<TResolver>();
        private static readonly Int64Utf8Formatter<TResolver> ElementFormatter = Int64Utf8Formatter<TResolver>.Default;

        public Int64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableInt64Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int64?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt64Utf8ArrayFormatter<TResolver> Default = new NullableInt64Utf8ArrayFormatter<TResolver>();
        private static readonly NullableInt64Utf8Formatter<TResolver> ElementFormatter = NullableInt64Utf8Formatter<TResolver>.Default;

        public Int64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = new Int64?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt64Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int64?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableInt64Utf8ListFormatter<TResolver> Default = new NullableInt64Utf8ListFormatter<TResolver>();
        private static readonly NullableInt64Utf8Formatter<TResolver> ElementFormatter = NullableInt64Utf8Formatter<TResolver>.Default;

        public List<Int64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf8ArrayFormatter<TResolver> : IJsonFormatter<Int64[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int64Utf8ArrayFormatter<TResolver> Default = new Int64Utf8ArrayFormatter<TResolver>();
        private static readonly Int64Utf8Formatter<TResolver> ElementFormatter = Int64Utf8Formatter<TResolver>.Default;

        public Int64[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = new Int64[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf8ListFormatter<TResolver> : IJsonFormatter<List<Int64>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly Int64Utf8ListFormatter<TResolver> Default = new Int64Utf8ListFormatter<TResolver>();
        private static readonly Int64Utf8Formatter<TResolver> ElementFormatter = Int64Utf8Formatter<TResolver>.Default;

        public List<Int64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf16Formatter<TResolver> : IJsonFormatter<Byte, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly ByteUtf16Formatter<TResolver> Default = new ByteUtf16Formatter<TResolver>();

        public Byte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Byte();
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte value, int nestingLimit)
        {
            writer.WriteUtf16Byte(value);
        }
    }

    public sealed class NullableByteUtf16Formatter<TResolver> : IJsonFormatter<Byte?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableByteUtf16Formatter<TResolver> Default = new NullableByteUtf16Formatter<TResolver>();
        private static readonly ByteUtf16Formatter<TResolver> ElementFormatter = ByteUtf16Formatter<TResolver>.Default;

        public Byte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableByteUtf16ArrayFormatter<TResolver> : IJsonFormatter<Byte?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableByteUtf16ArrayFormatter<TResolver> Default = new NullableByteUtf16ArrayFormatter<TResolver>();
        private static readonly NullableByteUtf16Formatter<TResolver> ElementFormatter = NullableByteUtf16Formatter<TResolver>.Default;

        public Byte?[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = new Byte?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableByteUtf16ListFormatter<TResolver> : IJsonFormatter<List<Byte?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableByteUtf16ListFormatter<TResolver> Default = new NullableByteUtf16ListFormatter<TResolver>();
        private static readonly NullableByteUtf16Formatter<TResolver> ElementFormatter = NullableByteUtf16Formatter<TResolver>.Default;

        public List<Byte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Byte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf16ArrayFormatter<TResolver> : IJsonFormatter<Byte[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly ByteUtf16ArrayFormatter<TResolver> Default = new ByteUtf16ArrayFormatter<TResolver>();
        private static readonly ByteUtf16Formatter<TResolver> ElementFormatter = ByteUtf16Formatter<TResolver>.Default;

        public Byte[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = new Byte[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf16ListFormatter<TResolver> : IJsonFormatter<List<Byte>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly ByteUtf16ListFormatter<TResolver> Default = new ByteUtf16ListFormatter<TResolver>();
        private static readonly ByteUtf16Formatter<TResolver> ElementFormatter = ByteUtf16Formatter<TResolver>.Default;

        public List<Byte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Byte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf8Formatter<TResolver> : IJsonFormatter<Byte, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly ByteUtf8Formatter<TResolver> Default = new ByteUtf8Formatter<TResolver>();

        public Byte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Byte();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte value, int nestingLimit)
        {
            writer.WriteUtf8Byte(value);
        }
    }

    public sealed class NullableByteUtf8Formatter<TResolver> : IJsonFormatter<Byte?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableByteUtf8Formatter<TResolver> Default = new NullableByteUtf8Formatter<TResolver>();
        private static readonly ByteUtf8Formatter<TResolver> ElementFormatter = ByteUtf8Formatter<TResolver>.Default;

        public Byte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableByteUtf8ArrayFormatter<TResolver> : IJsonFormatter<Byte?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableByteUtf8ArrayFormatter<TResolver> Default = new NullableByteUtf8ArrayFormatter<TResolver>();
        private static readonly NullableByteUtf8Formatter<TResolver> ElementFormatter = NullableByteUtf8Formatter<TResolver>.Default;

        public Byte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = new Byte?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableByteUtf8ListFormatter<TResolver> : IJsonFormatter<List<Byte?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableByteUtf8ListFormatter<TResolver> Default = new NullableByteUtf8ListFormatter<TResolver>();
        private static readonly NullableByteUtf8Formatter<TResolver> ElementFormatter = NullableByteUtf8Formatter<TResolver>.Default;

        public List<Byte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf8ArrayFormatter<TResolver> : IJsonFormatter<Byte[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly ByteUtf8ArrayFormatter<TResolver> Default = new ByteUtf8ArrayFormatter<TResolver>();
        private static readonly ByteUtf8Formatter<TResolver> ElementFormatter = ByteUtf8Formatter<TResolver>.Default;

        public Byte[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = new Byte[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf8ListFormatter<TResolver> : IJsonFormatter<List<Byte>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly ByteUtf8ListFormatter<TResolver> Default = new ByteUtf8ListFormatter<TResolver>();
        private static readonly ByteUtf8Formatter<TResolver> ElementFormatter = ByteUtf8Formatter<TResolver>.Default;

        public List<Byte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf16Formatter<TResolver> : IJsonFormatter<UInt16, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt16Utf16Formatter<TResolver> Default = new UInt16Utf16Formatter<TResolver>();

        public UInt16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt16();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16 value, int nestingLimit)
        {
            writer.WriteUtf16UInt16(value);
        }
    }

    public sealed class NullableUInt16Utf16Formatter<TResolver> : IJsonFormatter<UInt16?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt16Utf16Formatter<TResolver> Default = new NullableUInt16Utf16Formatter<TResolver>();
        private static readonly UInt16Utf16Formatter<TResolver> ElementFormatter = UInt16Utf16Formatter<TResolver>.Default;

        public UInt16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt16Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt16?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt16Utf16ArrayFormatter<TResolver> Default = new NullableUInt16Utf16ArrayFormatter<TResolver>();
        private static readonly NullableUInt16Utf16Formatter<TResolver> ElementFormatter = NullableUInt16Utf16Formatter<TResolver>.Default;

        public UInt16?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = new UInt16?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt16Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt16?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt16Utf16ListFormatter<TResolver> Default = new NullableUInt16Utf16ListFormatter<TResolver>();
        private static readonly NullableUInt16Utf16Formatter<TResolver> ElementFormatter = NullableUInt16Utf16Formatter<TResolver>.Default;

        public List<UInt16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt16[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt16Utf16ArrayFormatter<TResolver> Default = new UInt16Utf16ArrayFormatter<TResolver>();
        private static readonly UInt16Utf16Formatter<TResolver> ElementFormatter = UInt16Utf16Formatter<TResolver>.Default;

        public UInt16[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = new UInt16[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt16>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt16Utf16ListFormatter<TResolver> Default = new UInt16Utf16ListFormatter<TResolver>();
        private static readonly UInt16Utf16Formatter<TResolver> ElementFormatter = UInt16Utf16Formatter<TResolver>.Default;

        public List<UInt16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf8Formatter<TResolver> : IJsonFormatter<UInt16, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt16Utf8Formatter<TResolver> Default = new UInt16Utf8Formatter<TResolver>();

        public UInt16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt16();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16 value, int nestingLimit)
        {
            writer.WriteUtf8UInt16(value);
        }
    }

    public sealed class NullableUInt16Utf8Formatter<TResolver> : IJsonFormatter<UInt16?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt16Utf8Formatter<TResolver> Default = new NullableUInt16Utf8Formatter<TResolver>();
        private static readonly UInt16Utf8Formatter<TResolver> ElementFormatter = UInt16Utf8Formatter<TResolver>.Default;

        public UInt16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt16Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt16?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt16Utf8ArrayFormatter<TResolver> Default = new NullableUInt16Utf8ArrayFormatter<TResolver>();
        private static readonly NullableUInt16Utf8Formatter<TResolver> ElementFormatter = NullableUInt16Utf8Formatter<TResolver>.Default;

        public UInt16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = new UInt16?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt16Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt16?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt16Utf8ListFormatter<TResolver> Default = new NullableUInt16Utf8ListFormatter<TResolver>();
        private static readonly NullableUInt16Utf8Formatter<TResolver> ElementFormatter = NullableUInt16Utf8Formatter<TResolver>.Default;

        public List<UInt16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt16[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt16Utf8ArrayFormatter<TResolver> Default = new UInt16Utf8ArrayFormatter<TResolver>();
        private static readonly UInt16Utf8Formatter<TResolver> ElementFormatter = UInt16Utf8Formatter<TResolver>.Default;

        public UInt16[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = new UInt16[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt16>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt16Utf8ListFormatter<TResolver> Default = new UInt16Utf8ListFormatter<TResolver>();
        private static readonly UInt16Utf8Formatter<TResolver> ElementFormatter = UInt16Utf8Formatter<TResolver>.Default;

        public List<UInt16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf16Formatter<TResolver> : IJsonFormatter<UInt32, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt32Utf16Formatter<TResolver> Default = new UInt32Utf16Formatter<TResolver>();

        public UInt32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt32();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32 value, int nestingLimit)
        {
            writer.WriteUtf16UInt32(value);
        }
    }

    public sealed class NullableUInt32Utf16Formatter<TResolver> : IJsonFormatter<UInt32?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt32Utf16Formatter<TResolver> Default = new NullableUInt32Utf16Formatter<TResolver>();
        private static readonly UInt32Utf16Formatter<TResolver> ElementFormatter = UInt32Utf16Formatter<TResolver>.Default;

        public UInt32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt32Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt32?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt32Utf16ArrayFormatter<TResolver> Default = new NullableUInt32Utf16ArrayFormatter<TResolver>();
        private static readonly NullableUInt32Utf16Formatter<TResolver> ElementFormatter = NullableUInt32Utf16Formatter<TResolver>.Default;

        public UInt32?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = new UInt32?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt32Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt32?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt32Utf16ListFormatter<TResolver> Default = new NullableUInt32Utf16ListFormatter<TResolver>();
        private static readonly NullableUInt32Utf16Formatter<TResolver> ElementFormatter = NullableUInt32Utf16Formatter<TResolver>.Default;

        public List<UInt32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt32[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt32Utf16ArrayFormatter<TResolver> Default = new UInt32Utf16ArrayFormatter<TResolver>();
        private static readonly UInt32Utf16Formatter<TResolver> ElementFormatter = UInt32Utf16Formatter<TResolver>.Default;

        public UInt32[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = new UInt32[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt32>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt32Utf16ListFormatter<TResolver> Default = new UInt32Utf16ListFormatter<TResolver>();
        private static readonly UInt32Utf16Formatter<TResolver> ElementFormatter = UInt32Utf16Formatter<TResolver>.Default;

        public List<UInt32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf8Formatter<TResolver> : IJsonFormatter<UInt32, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt32Utf8Formatter<TResolver> Default = new UInt32Utf8Formatter<TResolver>();

        public UInt32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt32();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32 value, int nestingLimit)
        {
            writer.WriteUtf8UInt32(value);
        }
    }

    public sealed class NullableUInt32Utf8Formatter<TResolver> : IJsonFormatter<UInt32?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt32Utf8Formatter<TResolver> Default = new NullableUInt32Utf8Formatter<TResolver>();
        private static readonly UInt32Utf8Formatter<TResolver> ElementFormatter = UInt32Utf8Formatter<TResolver>.Default;

        public UInt32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt32Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt32?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt32Utf8ArrayFormatter<TResolver> Default = new NullableUInt32Utf8ArrayFormatter<TResolver>();
        private static readonly NullableUInt32Utf8Formatter<TResolver> ElementFormatter = NullableUInt32Utf8Formatter<TResolver>.Default;

        public UInt32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = new UInt32?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt32Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt32?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt32Utf8ListFormatter<TResolver> Default = new NullableUInt32Utf8ListFormatter<TResolver>();
        private static readonly NullableUInt32Utf8Formatter<TResolver> ElementFormatter = NullableUInt32Utf8Formatter<TResolver>.Default;

        public List<UInt32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt32[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt32Utf8ArrayFormatter<TResolver> Default = new UInt32Utf8ArrayFormatter<TResolver>();
        private static readonly UInt32Utf8Formatter<TResolver> ElementFormatter = UInt32Utf8Formatter<TResolver>.Default;

        public UInt32[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = new UInt32[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt32>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt32Utf8ListFormatter<TResolver> Default = new UInt32Utf8ListFormatter<TResolver>();
        private static readonly UInt32Utf8Formatter<TResolver> ElementFormatter = UInt32Utf8Formatter<TResolver>.Default;

        public List<UInt32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf16Formatter<TResolver> : IJsonFormatter<UInt64, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt64Utf16Formatter<TResolver> Default = new UInt64Utf16Formatter<TResolver>();

        public UInt64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt64();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64 value, int nestingLimit)
        {
            writer.WriteUtf16UInt64(value);
        }
    }

    public sealed class NullableUInt64Utf16Formatter<TResolver> : IJsonFormatter<UInt64?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt64Utf16Formatter<TResolver> Default = new NullableUInt64Utf16Formatter<TResolver>();
        private static readonly UInt64Utf16Formatter<TResolver> ElementFormatter = UInt64Utf16Formatter<TResolver>.Default;

        public UInt64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt64Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt64?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt64Utf16ArrayFormatter<TResolver> Default = new NullableUInt64Utf16ArrayFormatter<TResolver>();
        private static readonly NullableUInt64Utf16Formatter<TResolver> ElementFormatter = NullableUInt64Utf16Formatter<TResolver>.Default;

        public UInt64?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = new UInt64?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt64Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt64?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableUInt64Utf16ListFormatter<TResolver> Default = new NullableUInt64Utf16ListFormatter<TResolver>();
        private static readonly NullableUInt64Utf16Formatter<TResolver> ElementFormatter = NullableUInt64Utf16Formatter<TResolver>.Default;

        public List<UInt64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf16ArrayFormatter<TResolver> : IJsonFormatter<UInt64[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt64Utf16ArrayFormatter<TResolver> Default = new UInt64Utf16ArrayFormatter<TResolver>();
        private static readonly UInt64Utf16Formatter<TResolver> ElementFormatter = UInt64Utf16Formatter<TResolver>.Default;

        public UInt64[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = new UInt64[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf16ListFormatter<TResolver> : IJsonFormatter<List<UInt64>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UInt64Utf16ListFormatter<TResolver> Default = new UInt64Utf16ListFormatter<TResolver>();
        private static readonly UInt64Utf16Formatter<TResolver> ElementFormatter = UInt64Utf16Formatter<TResolver>.Default;

        public List<UInt64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf8Formatter<TResolver> : IJsonFormatter<UInt64, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt64Utf8Formatter<TResolver> Default = new UInt64Utf8Formatter<TResolver>();

        public UInt64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt64();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64 value, int nestingLimit)
        {
            writer.WriteUtf8UInt64(value);
        }
    }

    public sealed class NullableUInt64Utf8Formatter<TResolver> : IJsonFormatter<UInt64?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt64Utf8Formatter<TResolver> Default = new NullableUInt64Utf8Formatter<TResolver>();
        private static readonly UInt64Utf8Formatter<TResolver> ElementFormatter = UInt64Utf8Formatter<TResolver>.Default;

        public UInt64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableUInt64Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt64?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt64Utf8ArrayFormatter<TResolver> Default = new NullableUInt64Utf8ArrayFormatter<TResolver>();
        private static readonly NullableUInt64Utf8Formatter<TResolver> ElementFormatter = NullableUInt64Utf8Formatter<TResolver>.Default;

        public UInt64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = new UInt64?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt64Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt64?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableUInt64Utf8ListFormatter<TResolver> Default = new NullableUInt64Utf8ListFormatter<TResolver>();
        private static readonly NullableUInt64Utf8Formatter<TResolver> ElementFormatter = NullableUInt64Utf8Formatter<TResolver>.Default;

        public List<UInt64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf8ArrayFormatter<TResolver> : IJsonFormatter<UInt64[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt64Utf8ArrayFormatter<TResolver> Default = new UInt64Utf8ArrayFormatter<TResolver>();
        private static readonly UInt64Utf8Formatter<TResolver> ElementFormatter = UInt64Utf8Formatter<TResolver>.Default;

        public UInt64[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = new UInt64[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf8ListFormatter<TResolver> : IJsonFormatter<List<UInt64>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UInt64Utf8ListFormatter<TResolver> Default = new UInt64Utf8ListFormatter<TResolver>();
        private static readonly UInt64Utf8Formatter<TResolver> ElementFormatter = UInt64Utf8Formatter<TResolver>.Default;

        public List<UInt64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf16Formatter<TResolver> : IJsonFormatter<Single, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SingleUtf16Formatter<TResolver> Default = new SingleUtf16Formatter<TResolver>();

        public Single Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Single();
        }

        public void Serialize(ref JsonWriter<Char> writer, Single value, int nestingLimit)
        {
            writer.WriteUtf16Single(value);
        }
    }

    public sealed class NullableSingleUtf16Formatter<TResolver> : IJsonFormatter<Single?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSingleUtf16Formatter<TResolver> Default = new NullableSingleUtf16Formatter<TResolver>();
        private static readonly SingleUtf16Formatter<TResolver> ElementFormatter = SingleUtf16Formatter<TResolver>.Default;

        public Single? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Single? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableSingleUtf16ArrayFormatter<TResolver> : IJsonFormatter<Single?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSingleUtf16ArrayFormatter<TResolver> Default = new NullableSingleUtf16ArrayFormatter<TResolver>();
        private static readonly NullableSingleUtf16Formatter<TResolver> ElementFormatter = NullableSingleUtf16Formatter<TResolver>.Default;

        public Single?[] Deserialize(ref JsonReader<Char> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = new Single?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Single?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableSingleUtf16ListFormatter<TResolver> : IJsonFormatter<List<Single?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableSingleUtf16ListFormatter<TResolver> Default = new NullableSingleUtf16ListFormatter<TResolver>();
        private static readonly NullableSingleUtf16Formatter<TResolver> ElementFormatter = NullableSingleUtf16Formatter<TResolver>.Default;

        public List<Single?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Single?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf16ArrayFormatter<TResolver> : IJsonFormatter<Single[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SingleUtf16ArrayFormatter<TResolver> Default = new SingleUtf16ArrayFormatter<TResolver>();
        private static readonly SingleUtf16Formatter<TResolver> ElementFormatter = SingleUtf16Formatter<TResolver>.Default;

        public Single[] Deserialize(ref JsonReader<Char> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = new Single[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Single[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf16ListFormatter<TResolver> : IJsonFormatter<List<Single>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly SingleUtf16ListFormatter<TResolver> Default = new SingleUtf16ListFormatter<TResolver>();
        private static readonly SingleUtf16Formatter<TResolver> ElementFormatter = SingleUtf16Formatter<TResolver>.Default;

        public List<Single> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Single> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf8Formatter<TResolver> : IJsonFormatter<Single, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SingleUtf8Formatter<TResolver> Default = new SingleUtf8Formatter<TResolver>();

        public Single Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Single();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single value, int nestingLimit)
        {
            writer.WriteUtf8Single(value);
        }
    }

    public sealed class NullableSingleUtf8Formatter<TResolver> : IJsonFormatter<Single?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSingleUtf8Formatter<TResolver> Default = new NullableSingleUtf8Formatter<TResolver>();
        private static readonly SingleUtf8Formatter<TResolver> ElementFormatter = SingleUtf8Formatter<TResolver>.Default;

        public Single? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableSingleUtf8ArrayFormatter<TResolver> : IJsonFormatter<Single?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSingleUtf8ArrayFormatter<TResolver> Default = new NullableSingleUtf8ArrayFormatter<TResolver>();
        private static readonly NullableSingleUtf8Formatter<TResolver> ElementFormatter = NullableSingleUtf8Formatter<TResolver>.Default;

        public Single?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = new Single?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableSingleUtf8ListFormatter<TResolver> : IJsonFormatter<List<Single?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableSingleUtf8ListFormatter<TResolver> Default = new NullableSingleUtf8ListFormatter<TResolver>();
        private static readonly NullableSingleUtf8Formatter<TResolver> ElementFormatter = NullableSingleUtf8Formatter<TResolver>.Default;

        public List<Single?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Single?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf8ArrayFormatter<TResolver> : IJsonFormatter<Single[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SingleUtf8ArrayFormatter<TResolver> Default = new SingleUtf8ArrayFormatter<TResolver>();
        private static readonly SingleUtf8Formatter<TResolver> ElementFormatter = SingleUtf8Formatter<TResolver>.Default;

        public Single[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = new Single[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf8ListFormatter<TResolver> : IJsonFormatter<List<Single>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly SingleUtf8ListFormatter<TResolver> Default = new SingleUtf8ListFormatter<TResolver>();
        private static readonly SingleUtf8Formatter<TResolver> ElementFormatter = SingleUtf8Formatter<TResolver>.Default;

        public List<Single> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Single> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf16Formatter<TResolver> : IJsonFormatter<Double, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DoubleUtf16Formatter<TResolver> Default = new DoubleUtf16Formatter<TResolver>();

        public Double Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Double();
        }

        public void Serialize(ref JsonWriter<Char> writer, Double value, int nestingLimit)
        {
            writer.WriteUtf16Double(value);
        }
    }

    public sealed class NullableDoubleUtf16Formatter<TResolver> : IJsonFormatter<Double?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDoubleUtf16Formatter<TResolver> Default = new NullableDoubleUtf16Formatter<TResolver>();
        private static readonly DoubleUtf16Formatter<TResolver> ElementFormatter = DoubleUtf16Formatter<TResolver>.Default;

        public Double? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Double? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDoubleUtf16ArrayFormatter<TResolver> : IJsonFormatter<Double?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDoubleUtf16ArrayFormatter<TResolver> Default = new NullableDoubleUtf16ArrayFormatter<TResolver>();
        private static readonly NullableDoubleUtf16Formatter<TResolver> ElementFormatter = NullableDoubleUtf16Formatter<TResolver>.Default;

        public Double?[] Deserialize(ref JsonReader<Char> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = new Double?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Double?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDoubleUtf16ListFormatter<TResolver> : IJsonFormatter<List<Double?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDoubleUtf16ListFormatter<TResolver> Default = new NullableDoubleUtf16ListFormatter<TResolver>();
        private static readonly NullableDoubleUtf16Formatter<TResolver> ElementFormatter = NullableDoubleUtf16Formatter<TResolver>.Default;

        public List<Double?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Double?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf16ArrayFormatter<TResolver> : IJsonFormatter<Double[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DoubleUtf16ArrayFormatter<TResolver> Default = new DoubleUtf16ArrayFormatter<TResolver>();
        private static readonly DoubleUtf16Formatter<TResolver> ElementFormatter = DoubleUtf16Formatter<TResolver>.Default;

        public Double[] Deserialize(ref JsonReader<Char> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = new Double[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Double[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf16ListFormatter<TResolver> : IJsonFormatter<List<Double>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DoubleUtf16ListFormatter<TResolver> Default = new DoubleUtf16ListFormatter<TResolver>();
        private static readonly DoubleUtf16Formatter<TResolver> ElementFormatter = DoubleUtf16Formatter<TResolver>.Default;

        public List<Double> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Double> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf8Formatter<TResolver> : IJsonFormatter<Double, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DoubleUtf8Formatter<TResolver> Default = new DoubleUtf8Formatter<TResolver>();

        public Double Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Double();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double value, int nestingLimit)
        {
            writer.WriteUtf8Double(value);
        }
    }

    public sealed class NullableDoubleUtf8Formatter<TResolver> : IJsonFormatter<Double?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDoubleUtf8Formatter<TResolver> Default = new NullableDoubleUtf8Formatter<TResolver>();
        private static readonly DoubleUtf8Formatter<TResolver> ElementFormatter = DoubleUtf8Formatter<TResolver>.Default;

        public Double? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDoubleUtf8ArrayFormatter<TResolver> : IJsonFormatter<Double?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDoubleUtf8ArrayFormatter<TResolver> Default = new NullableDoubleUtf8ArrayFormatter<TResolver>();
        private static readonly NullableDoubleUtf8Formatter<TResolver> ElementFormatter = NullableDoubleUtf8Formatter<TResolver>.Default;

        public Double?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = new Double?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDoubleUtf8ListFormatter<TResolver> : IJsonFormatter<List<Double?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDoubleUtf8ListFormatter<TResolver> Default = new NullableDoubleUtf8ListFormatter<TResolver>();
        private static readonly NullableDoubleUtf8Formatter<TResolver> ElementFormatter = NullableDoubleUtf8Formatter<TResolver>.Default;

        public List<Double?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Double?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf8ArrayFormatter<TResolver> : IJsonFormatter<Double[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DoubleUtf8ArrayFormatter<TResolver> Default = new DoubleUtf8ArrayFormatter<TResolver>();
        private static readonly DoubleUtf8Formatter<TResolver> ElementFormatter = DoubleUtf8Formatter<TResolver>.Default;

        public Double[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = new Double[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf8ListFormatter<TResolver> : IJsonFormatter<List<Double>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DoubleUtf8ListFormatter<TResolver> Default = new DoubleUtf8ListFormatter<TResolver>();
        private static readonly DoubleUtf8Formatter<TResolver> ElementFormatter = DoubleUtf8Formatter<TResolver>.Default;

        public List<Double> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Double> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf16Formatter<TResolver> : IJsonFormatter<Decimal, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DecimalUtf16Formatter<TResolver> Default = new DecimalUtf16Formatter<TResolver>();

        public Decimal Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Decimal();
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal value, int nestingLimit)
        {
            writer.WriteUtf16Decimal(value);
        }
    }

    public sealed class NullableDecimalUtf16Formatter<TResolver> : IJsonFormatter<Decimal?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDecimalUtf16Formatter<TResolver> Default = new NullableDecimalUtf16Formatter<TResolver>();
        private static readonly DecimalUtf16Formatter<TResolver> ElementFormatter = DecimalUtf16Formatter<TResolver>.Default;

        public Decimal? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDecimalUtf16ArrayFormatter<TResolver> : IJsonFormatter<Decimal?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDecimalUtf16ArrayFormatter<TResolver> Default = new NullableDecimalUtf16ArrayFormatter<TResolver>();
        private static readonly NullableDecimalUtf16Formatter<TResolver> ElementFormatter = NullableDecimalUtf16Formatter<TResolver>.Default;

        public Decimal?[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = new Decimal?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDecimalUtf16ListFormatter<TResolver> : IJsonFormatter<List<Decimal?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDecimalUtf16ListFormatter<TResolver> Default = new NullableDecimalUtf16ListFormatter<TResolver>();
        private static readonly NullableDecimalUtf16Formatter<TResolver> ElementFormatter = NullableDecimalUtf16Formatter<TResolver>.Default;

        public List<Decimal?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf16ArrayFormatter<TResolver> : IJsonFormatter<Decimal[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DecimalUtf16ArrayFormatter<TResolver> Default = new DecimalUtf16ArrayFormatter<TResolver>();
        private static readonly DecimalUtf16Formatter<TResolver> ElementFormatter = DecimalUtf16Formatter<TResolver>.Default;

        public Decimal[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = new Decimal[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf16ListFormatter<TResolver> : IJsonFormatter<List<Decimal>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DecimalUtf16ListFormatter<TResolver> Default = new DecimalUtf16ListFormatter<TResolver>();
        private static readonly DecimalUtf16Formatter<TResolver> ElementFormatter = DecimalUtf16Formatter<TResolver>.Default;

        public List<Decimal> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf8Formatter<TResolver> : IJsonFormatter<Decimal, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DecimalUtf8Formatter<TResolver> Default = new DecimalUtf8Formatter<TResolver>();

        public Decimal Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Decimal();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal value, int nestingLimit)
        {
            writer.WriteUtf8Decimal(value);
        }
    }

    public sealed class NullableDecimalUtf8Formatter<TResolver> : IJsonFormatter<Decimal?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDecimalUtf8Formatter<TResolver> Default = new NullableDecimalUtf8Formatter<TResolver>();
        private static readonly DecimalUtf8Formatter<TResolver> ElementFormatter = DecimalUtf8Formatter<TResolver>.Default;

        public Decimal? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDecimalUtf8ArrayFormatter<TResolver> : IJsonFormatter<Decimal?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDecimalUtf8ArrayFormatter<TResolver> Default = new NullableDecimalUtf8ArrayFormatter<TResolver>();
        private static readonly NullableDecimalUtf8Formatter<TResolver> ElementFormatter = NullableDecimalUtf8Formatter<TResolver>.Default;

        public Decimal?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = new Decimal?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDecimalUtf8ListFormatter<TResolver> : IJsonFormatter<List<Decimal?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDecimalUtf8ListFormatter<TResolver> Default = new NullableDecimalUtf8ListFormatter<TResolver>();
        private static readonly NullableDecimalUtf8Formatter<TResolver> ElementFormatter = NullableDecimalUtf8Formatter<TResolver>.Default;

        public List<Decimal?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf8ArrayFormatter<TResolver> : IJsonFormatter<Decimal[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DecimalUtf8ArrayFormatter<TResolver> Default = new DecimalUtf8ArrayFormatter<TResolver>();
        private static readonly DecimalUtf8Formatter<TResolver> ElementFormatter = DecimalUtf8Formatter<TResolver>.Default;

        public Decimal[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = new Decimal[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf8ListFormatter<TResolver> : IJsonFormatter<List<Decimal>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DecimalUtf8ListFormatter<TResolver> Default = new DecimalUtf8ListFormatter<TResolver>();
        private static readonly DecimalUtf8Formatter<TResolver> ElementFormatter = DecimalUtf8Formatter<TResolver>.Default;

        public List<Decimal> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf16Formatter<TResolver> : IJsonFormatter<Boolean, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly BooleanUtf16Formatter<TResolver> Default = new BooleanUtf16Formatter<TResolver>();

        public Boolean Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Boolean();
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean value, int nestingLimit)
        {
            writer.WriteUtf16Boolean(value);
        }
    }

    public sealed class NullableBooleanUtf16Formatter<TResolver> : IJsonFormatter<Boolean?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableBooleanUtf16Formatter<TResolver> Default = new NullableBooleanUtf16Formatter<TResolver>();
        private static readonly BooleanUtf16Formatter<TResolver> ElementFormatter = BooleanUtf16Formatter<TResolver>.Default;

        public Boolean? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableBooleanUtf16ArrayFormatter<TResolver> : IJsonFormatter<Boolean?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableBooleanUtf16ArrayFormatter<TResolver> Default = new NullableBooleanUtf16ArrayFormatter<TResolver>();
        private static readonly NullableBooleanUtf16Formatter<TResolver> ElementFormatter = NullableBooleanUtf16Formatter<TResolver>.Default;

        public Boolean?[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = new Boolean?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableBooleanUtf16ListFormatter<TResolver> : IJsonFormatter<List<Boolean?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableBooleanUtf16ListFormatter<TResolver> Default = new NullableBooleanUtf16ListFormatter<TResolver>();
        private static readonly NullableBooleanUtf16Formatter<TResolver> ElementFormatter = NullableBooleanUtf16Formatter<TResolver>.Default;

        public List<Boolean?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf16ArrayFormatter<TResolver> : IJsonFormatter<Boolean[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly BooleanUtf16ArrayFormatter<TResolver> Default = new BooleanUtf16ArrayFormatter<TResolver>();
        private static readonly BooleanUtf16Formatter<TResolver> ElementFormatter = BooleanUtf16Formatter<TResolver>.Default;

        public Boolean[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = new Boolean[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf16ListFormatter<TResolver> : IJsonFormatter<List<Boolean>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly BooleanUtf16ListFormatter<TResolver> Default = new BooleanUtf16ListFormatter<TResolver>();
        private static readonly BooleanUtf16Formatter<TResolver> ElementFormatter = BooleanUtf16Formatter<TResolver>.Default;

        public List<Boolean> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf8Formatter<TResolver> : IJsonFormatter<Boolean, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly BooleanUtf8Formatter<TResolver> Default = new BooleanUtf8Formatter<TResolver>();

        public Boolean Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Boolean();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean value, int nestingLimit)
        {
            writer.WriteUtf8Boolean(value);
        }
    }

    public sealed class NullableBooleanUtf8Formatter<TResolver> : IJsonFormatter<Boolean?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableBooleanUtf8Formatter<TResolver> Default = new NullableBooleanUtf8Formatter<TResolver>();
        private static readonly BooleanUtf8Formatter<TResolver> ElementFormatter = BooleanUtf8Formatter<TResolver>.Default;

        public Boolean? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableBooleanUtf8ArrayFormatter<TResolver> : IJsonFormatter<Boolean?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableBooleanUtf8ArrayFormatter<TResolver> Default = new NullableBooleanUtf8ArrayFormatter<TResolver>();
        private static readonly NullableBooleanUtf8Formatter<TResolver> ElementFormatter = NullableBooleanUtf8Formatter<TResolver>.Default;

        public Boolean?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = new Boolean?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableBooleanUtf8ListFormatter<TResolver> : IJsonFormatter<List<Boolean?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableBooleanUtf8ListFormatter<TResolver> Default = new NullableBooleanUtf8ListFormatter<TResolver>();
        private static readonly NullableBooleanUtf8Formatter<TResolver> ElementFormatter = NullableBooleanUtf8Formatter<TResolver>.Default;

        public List<Boolean?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf8ArrayFormatter<TResolver> : IJsonFormatter<Boolean[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly BooleanUtf8ArrayFormatter<TResolver> Default = new BooleanUtf8ArrayFormatter<TResolver>();
        private static readonly BooleanUtf8Formatter<TResolver> ElementFormatter = BooleanUtf8Formatter<TResolver>.Default;

        public Boolean[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = new Boolean[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf8ListFormatter<TResolver> : IJsonFormatter<List<Boolean>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly BooleanUtf8ListFormatter<TResolver> Default = new BooleanUtf8ListFormatter<TResolver>();
        private static readonly BooleanUtf8Formatter<TResolver> ElementFormatter = BooleanUtf8Formatter<TResolver>.Default;

        public List<Boolean> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf16Formatter<TResolver> : IJsonFormatter<Char, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly CharUtf16Formatter<TResolver> Default = new CharUtf16Formatter<TResolver>();

        public Char Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Char();
        }

        public void Serialize(ref JsonWriter<Char> writer, Char value, int nestingLimit)
        {
            writer.WriteUtf16Char(value);
        }
    }

    public sealed class NullableCharUtf16Formatter<TResolver> : IJsonFormatter<Char?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableCharUtf16Formatter<TResolver> Default = new NullableCharUtf16Formatter<TResolver>();
        private static readonly CharUtf16Formatter<TResolver> ElementFormatter = CharUtf16Formatter<TResolver>.Default;

        public Char? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Char? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableCharUtf16ArrayFormatter<TResolver> : IJsonFormatter<Char?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableCharUtf16ArrayFormatter<TResolver> Default = new NullableCharUtf16ArrayFormatter<TResolver>();
        private static readonly NullableCharUtf16Formatter<TResolver> ElementFormatter = NullableCharUtf16Formatter<TResolver>.Default;

        public Char?[] Deserialize(ref JsonReader<Char> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = new Char?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Char?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableCharUtf16ListFormatter<TResolver> : IJsonFormatter<List<Char?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableCharUtf16ListFormatter<TResolver> Default = new NullableCharUtf16ListFormatter<TResolver>();
        private static readonly NullableCharUtf16Formatter<TResolver> ElementFormatter = NullableCharUtf16Formatter<TResolver>.Default;

        public List<Char?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Char?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf16ArrayFormatter<TResolver> : IJsonFormatter<Char[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly CharUtf16ArrayFormatter<TResolver> Default = new CharUtf16ArrayFormatter<TResolver>();
        private static readonly CharUtf16Formatter<TResolver> ElementFormatter = CharUtf16Formatter<TResolver>.Default;

        public Char[] Deserialize(ref JsonReader<Char> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = new Char[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Char[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf16ListFormatter<TResolver> : IJsonFormatter<List<Char>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly CharUtf16ListFormatter<TResolver> Default = new CharUtf16ListFormatter<TResolver>();
        private static readonly CharUtf16Formatter<TResolver> ElementFormatter = CharUtf16Formatter<TResolver>.Default;

        public List<Char> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Char> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf8Formatter<TResolver> : IJsonFormatter<Char, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly CharUtf8Formatter<TResolver> Default = new CharUtf8Formatter<TResolver>();

        public Char Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Char();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char value, int nestingLimit)
        {
            writer.WriteUtf8Char(value);
        }
    }

    public sealed class NullableCharUtf8Formatter<TResolver> : IJsonFormatter<Char?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableCharUtf8Formatter<TResolver> Default = new NullableCharUtf8Formatter<TResolver>();
        private static readonly CharUtf8Formatter<TResolver> ElementFormatter = CharUtf8Formatter<TResolver>.Default;

        public Char? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableCharUtf8ArrayFormatter<TResolver> : IJsonFormatter<Char?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableCharUtf8ArrayFormatter<TResolver> Default = new NullableCharUtf8ArrayFormatter<TResolver>();
        private static readonly NullableCharUtf8Formatter<TResolver> ElementFormatter = NullableCharUtf8Formatter<TResolver>.Default;

        public Char?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = new Char?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableCharUtf8ListFormatter<TResolver> : IJsonFormatter<List<Char?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableCharUtf8ListFormatter<TResolver> Default = new NullableCharUtf8ListFormatter<TResolver>();
        private static readonly NullableCharUtf8Formatter<TResolver> ElementFormatter = NullableCharUtf8Formatter<TResolver>.Default;

        public List<Char?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Char?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf8ArrayFormatter<TResolver> : IJsonFormatter<Char[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly CharUtf8ArrayFormatter<TResolver> Default = new CharUtf8ArrayFormatter<TResolver>();
        private static readonly CharUtf8Formatter<TResolver> ElementFormatter = CharUtf8Formatter<TResolver>.Default;

        public Char[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = new Char[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf8ListFormatter<TResolver> : IJsonFormatter<List<Char>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly CharUtf8ListFormatter<TResolver> Default = new CharUtf8ListFormatter<TResolver>();
        private static readonly CharUtf8Formatter<TResolver> ElementFormatter = CharUtf8Formatter<TResolver>.Default;

        public List<Char> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Char> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf16Formatter<TResolver> : IJsonFormatter<DateTime, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeUtf16Formatter<TResolver> Default = new DateTimeUtf16Formatter<TResolver>();

        public DateTime Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTime();
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime value, int nestingLimit)
        {
            writer.WriteUtf16DateTime(value);
        }
    }

    public sealed class NullableDateTimeUtf16Formatter<TResolver> : IJsonFormatter<DateTime?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf16Formatter<TResolver> Default = new NullableDateTimeUtf16Formatter<TResolver>();
        private static readonly DateTimeUtf16Formatter<TResolver> ElementFormatter = DateTimeUtf16Formatter<TResolver>.Default;

        public DateTime? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDateTimeUtf16ArrayFormatter<TResolver> : IJsonFormatter<DateTime?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf16ArrayFormatter<TResolver> Default = new NullableDateTimeUtf16ArrayFormatter<TResolver>();
        private static readonly NullableDateTimeUtf16Formatter<TResolver> ElementFormatter = NullableDateTimeUtf16Formatter<TResolver>.Default;

        public DateTime?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = new DateTime?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDateTimeUtf16ListFormatter<TResolver> : IJsonFormatter<List<DateTime?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf16ListFormatter<TResolver> Default = new NullableDateTimeUtf16ListFormatter<TResolver>();
        private static readonly NullableDateTimeUtf16Formatter<TResolver> ElementFormatter = NullableDateTimeUtf16Formatter<TResolver>.Default;

        public List<DateTime?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf16ArrayFormatter<TResolver> : IJsonFormatter<DateTime[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeUtf16ArrayFormatter<TResolver> Default = new DateTimeUtf16ArrayFormatter<TResolver>();
        private static readonly DateTimeUtf16Formatter<TResolver> ElementFormatter = DateTimeUtf16Formatter<TResolver>.Default;

        public DateTime[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = new DateTime[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf16ListFormatter<TResolver> : IJsonFormatter<List<DateTime>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeUtf16ListFormatter<TResolver> Default = new DateTimeUtf16ListFormatter<TResolver>();
        private static readonly DateTimeUtf16Formatter<TResolver> ElementFormatter = DateTimeUtf16Formatter<TResolver>.Default;

        public List<DateTime> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf8Formatter<TResolver> : IJsonFormatter<DateTime, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeUtf8Formatter<TResolver> Default = new DateTimeUtf8Formatter<TResolver>();

        public DateTime Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTime();
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime value, int nestingLimit)
        {
            writer.WriteUtf8DateTime(value);
        }
    }

    public sealed class NullableDateTimeUtf8Formatter<TResolver> : IJsonFormatter<DateTime?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf8Formatter<TResolver> Default = new NullableDateTimeUtf8Formatter<TResolver>();
        private static readonly DateTimeUtf8Formatter<TResolver> ElementFormatter = DateTimeUtf8Formatter<TResolver>.Default;

        public DateTime? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDateTimeUtf8ArrayFormatter<TResolver> : IJsonFormatter<DateTime?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf8ArrayFormatter<TResolver> Default = new NullableDateTimeUtf8ArrayFormatter<TResolver>();
        private static readonly NullableDateTimeUtf8Formatter<TResolver> ElementFormatter = NullableDateTimeUtf8Formatter<TResolver>.Default;

        public DateTime?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = new DateTime?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDateTimeUtf8ListFormatter<TResolver> : IJsonFormatter<List<DateTime?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeUtf8ListFormatter<TResolver> Default = new NullableDateTimeUtf8ListFormatter<TResolver>();
        private static readonly NullableDateTimeUtf8Formatter<TResolver> ElementFormatter = NullableDateTimeUtf8Formatter<TResolver>.Default;

        public List<DateTime?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf8ArrayFormatter<TResolver> : IJsonFormatter<DateTime[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeUtf8ArrayFormatter<TResolver> Default = new DateTimeUtf8ArrayFormatter<TResolver>();
        private static readonly DateTimeUtf8Formatter<TResolver> ElementFormatter = DateTimeUtf8Formatter<TResolver>.Default;

        public DateTime[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = new DateTime[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf8ListFormatter<TResolver> : IJsonFormatter<List<DateTime>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeUtf8ListFormatter<TResolver> Default = new DateTimeUtf8ListFormatter<TResolver>();
        private static readonly DateTimeUtf8Formatter<TResolver> ElementFormatter = DateTimeUtf8Formatter<TResolver>.Default;

        public List<DateTime> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16Formatter<TResolver> : IJsonFormatter<DateTimeOffset, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf16Formatter<TResolver> Default = new DateTimeOffsetUtf16Formatter<TResolver>();

        public DateTimeOffset Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTimeOffset();
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset value, int nestingLimit)
        {
            writer.WriteUtf16DateTimeOffset(value);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16Formatter<TResolver> : IJsonFormatter<DateTimeOffset?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf16Formatter<TResolver> Default = new NullableDateTimeOffsetUtf16Formatter<TResolver>();
        private static readonly DateTimeOffsetUtf16Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf16Formatter<TResolver>.Default;

        public DateTimeOffset? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ArrayFormatter<TResolver> : IJsonFormatter<DateTimeOffset?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf16ArrayFormatter<TResolver> Default = new NullableDateTimeOffsetUtf16ArrayFormatter<TResolver>();
        private static readonly NullableDateTimeOffsetUtf16Formatter<TResolver> ElementFormatter = NullableDateTimeOffsetUtf16Formatter<TResolver>.Default;

        public DateTimeOffset?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = new DateTimeOffset?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ListFormatter<TResolver> : IJsonFormatter<List<DateTimeOffset?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf16ListFormatter<TResolver> Default = new NullableDateTimeOffsetUtf16ListFormatter<TResolver>();
        private static readonly NullableDateTimeOffsetUtf16Formatter<TResolver> ElementFormatter = NullableDateTimeOffsetUtf16Formatter<TResolver>.Default;

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16ArrayFormatter<TResolver> : IJsonFormatter<DateTimeOffset[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf16ArrayFormatter<TResolver> Default = new DateTimeOffsetUtf16ArrayFormatter<TResolver>();
        private static readonly DateTimeOffsetUtf16Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf16Formatter<TResolver>.Default;

        public DateTimeOffset[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = new DateTimeOffset[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16ListFormatter<TResolver> : IJsonFormatter<List<DateTimeOffset>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf16ListFormatter<TResolver> Default = new DateTimeOffsetUtf16ListFormatter<TResolver>();
        private static readonly DateTimeOffsetUtf16Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf16Formatter<TResolver>.Default;

        public List<DateTimeOffset> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8Formatter<TResolver> : IJsonFormatter<DateTimeOffset, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf8Formatter<TResolver> Default = new DateTimeOffsetUtf8Formatter<TResolver>();

        public DateTimeOffset Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTimeOffset();
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset value, int nestingLimit)
        {
            writer.WriteUtf8DateTimeOffset(value);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8Formatter<TResolver> : IJsonFormatter<DateTimeOffset?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf8Formatter<TResolver> Default = new NullableDateTimeOffsetUtf8Formatter<TResolver>();
        private static readonly DateTimeOffsetUtf8Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf8Formatter<TResolver>.Default;

        public DateTimeOffset? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ArrayFormatter<TResolver> : IJsonFormatter<DateTimeOffset?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf8ArrayFormatter<TResolver> Default = new NullableDateTimeOffsetUtf8ArrayFormatter<TResolver>();
        private static readonly NullableDateTimeOffsetUtf8Formatter<TResolver> ElementFormatter = NullableDateTimeOffsetUtf8Formatter<TResolver>.Default;

        public DateTimeOffset?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = new DateTimeOffset?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ListFormatter<TResolver> : IJsonFormatter<List<DateTimeOffset?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableDateTimeOffsetUtf8ListFormatter<TResolver> Default = new NullableDateTimeOffsetUtf8ListFormatter<TResolver>();
        private static readonly NullableDateTimeOffsetUtf8Formatter<TResolver> ElementFormatter = NullableDateTimeOffsetUtf8Formatter<TResolver>.Default;

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8ArrayFormatter<TResolver> : IJsonFormatter<DateTimeOffset[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf8ArrayFormatter<TResolver> Default = new DateTimeOffsetUtf8ArrayFormatter<TResolver>();
        private static readonly DateTimeOffsetUtf8Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf8Formatter<TResolver>.Default;

        public DateTimeOffset[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = new DateTimeOffset[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8ListFormatter<TResolver> : IJsonFormatter<List<DateTimeOffset>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly DateTimeOffsetUtf8ListFormatter<TResolver> Default = new DateTimeOffsetUtf8ListFormatter<TResolver>();
        private static readonly DateTimeOffsetUtf8Formatter<TResolver> ElementFormatter = DateTimeOffsetUtf8Formatter<TResolver>.Default;

        public List<DateTimeOffset> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf16Formatter<TResolver> : IJsonFormatter<TimeSpan, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly TimeSpanUtf16Formatter<TResolver> Default = new TimeSpanUtf16Formatter<TResolver>();

        public TimeSpan Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16TimeSpan();
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan value, int nestingLimit)
        {
            writer.WriteUtf16TimeSpan(value);
        }
    }

    public sealed class NullableTimeSpanUtf16Formatter<TResolver> : IJsonFormatter<TimeSpan?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf16Formatter<TResolver> Default = new NullableTimeSpanUtf16Formatter<TResolver>();
        private static readonly TimeSpanUtf16Formatter<TResolver> ElementFormatter = TimeSpanUtf16Formatter<TResolver>.Default;

        public TimeSpan? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableTimeSpanUtf16ArrayFormatter<TResolver> : IJsonFormatter<TimeSpan?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf16ArrayFormatter<TResolver> Default = new NullableTimeSpanUtf16ArrayFormatter<TResolver>();
        private static readonly NullableTimeSpanUtf16Formatter<TResolver> ElementFormatter = NullableTimeSpanUtf16Formatter<TResolver>.Default;

        public TimeSpan?[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = new TimeSpan?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableTimeSpanUtf16ListFormatter<TResolver> : IJsonFormatter<List<TimeSpan?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf16ListFormatter<TResolver> Default = new NullableTimeSpanUtf16ListFormatter<TResolver>();
        private static readonly NullableTimeSpanUtf16Formatter<TResolver> ElementFormatter = NullableTimeSpanUtf16Formatter<TResolver>.Default;

        public List<TimeSpan?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf16ArrayFormatter<TResolver> : IJsonFormatter<TimeSpan[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly TimeSpanUtf16ArrayFormatter<TResolver> Default = new TimeSpanUtf16ArrayFormatter<TResolver>();
        private static readonly TimeSpanUtf16Formatter<TResolver> ElementFormatter = TimeSpanUtf16Formatter<TResolver>.Default;

        public TimeSpan[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = new TimeSpan[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf16ListFormatter<TResolver> : IJsonFormatter<List<TimeSpan>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly TimeSpanUtf16ListFormatter<TResolver> Default = new TimeSpanUtf16ListFormatter<TResolver>();
        private static readonly TimeSpanUtf16Formatter<TResolver> ElementFormatter = TimeSpanUtf16Formatter<TResolver>.Default;

        public List<TimeSpan> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf8Formatter<TResolver> : IJsonFormatter<TimeSpan, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly TimeSpanUtf8Formatter<TResolver> Default = new TimeSpanUtf8Formatter<TResolver>();

        public TimeSpan Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8TimeSpan();
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan value, int nestingLimit)
        {
            writer.WriteUtf8TimeSpan(value);
        }
    }

    public sealed class NullableTimeSpanUtf8Formatter<TResolver> : IJsonFormatter<TimeSpan?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf8Formatter<TResolver> Default = new NullableTimeSpanUtf8Formatter<TResolver>();
        private static readonly TimeSpanUtf8Formatter<TResolver> ElementFormatter = TimeSpanUtf8Formatter<TResolver>.Default;

        public TimeSpan? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableTimeSpanUtf8ArrayFormatter<TResolver> : IJsonFormatter<TimeSpan?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf8ArrayFormatter<TResolver> Default = new NullableTimeSpanUtf8ArrayFormatter<TResolver>();
        private static readonly NullableTimeSpanUtf8Formatter<TResolver> ElementFormatter = NullableTimeSpanUtf8Formatter<TResolver>.Default;

        public TimeSpan?[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = new TimeSpan?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableTimeSpanUtf8ListFormatter<TResolver> : IJsonFormatter<List<TimeSpan?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableTimeSpanUtf8ListFormatter<TResolver> Default = new NullableTimeSpanUtf8ListFormatter<TResolver>();
        private static readonly NullableTimeSpanUtf8Formatter<TResolver> ElementFormatter = NullableTimeSpanUtf8Formatter<TResolver>.Default;

        public List<TimeSpan?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf8ArrayFormatter<TResolver> : IJsonFormatter<TimeSpan[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly TimeSpanUtf8ArrayFormatter<TResolver> Default = new TimeSpanUtf8ArrayFormatter<TResolver>();
        private static readonly TimeSpanUtf8Formatter<TResolver> ElementFormatter = TimeSpanUtf8Formatter<TResolver>.Default;

        public TimeSpan[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = new TimeSpan[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf8ListFormatter<TResolver> : IJsonFormatter<List<TimeSpan>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly TimeSpanUtf8ListFormatter<TResolver> Default = new TimeSpanUtf8ListFormatter<TResolver>();
        private static readonly TimeSpanUtf8Formatter<TResolver> ElementFormatter = TimeSpanUtf8Formatter<TResolver>.Default;

        public List<TimeSpan> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf16Formatter<TResolver> : IJsonFormatter<Guid, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly GuidUtf16Formatter<TResolver> Default = new GuidUtf16Formatter<TResolver>();

        public Guid Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Guid();
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid value, int nestingLimit)
        {
            writer.WriteUtf16Guid(value);
        }
    }

    public sealed class NullableGuidUtf16Formatter<TResolver> : IJsonFormatter<Guid?, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableGuidUtf16Formatter<TResolver> Default = new NullableGuidUtf16Formatter<TResolver>();
        private static readonly GuidUtf16Formatter<TResolver> ElementFormatter = GuidUtf16Formatter<TResolver>.Default;

        public Guid? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableGuidUtf16ArrayFormatter<TResolver> : IJsonFormatter<Guid?[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableGuidUtf16ArrayFormatter<TResolver> Default = new NullableGuidUtf16ArrayFormatter<TResolver>();
        private static readonly NullableGuidUtf16Formatter<TResolver> ElementFormatter = NullableGuidUtf16Formatter<TResolver>.Default;

        public Guid?[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = new Guid?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableGuidUtf16ListFormatter<TResolver> : IJsonFormatter<List<Guid?>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly NullableGuidUtf16ListFormatter<TResolver> Default = new NullableGuidUtf16ListFormatter<TResolver>();
        private static readonly NullableGuidUtf16Formatter<TResolver> ElementFormatter = NullableGuidUtf16Formatter<TResolver>.Default;

        public List<Guid?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Guid?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf16ArrayFormatter<TResolver> : IJsonFormatter<Guid[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly GuidUtf16ArrayFormatter<TResolver> Default = new GuidUtf16ArrayFormatter<TResolver>();
        private static readonly GuidUtf16Formatter<TResolver> ElementFormatter = GuidUtf16Formatter<TResolver>.Default;

        public Guid[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = new Guid[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf16ListFormatter<TResolver> : IJsonFormatter<List<Guid>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly GuidUtf16ListFormatter<TResolver> Default = new GuidUtf16ListFormatter<TResolver>();
        private static readonly GuidUtf16Formatter<TResolver> ElementFormatter = GuidUtf16Formatter<TResolver>.Default;

        public List<Guid> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Guid> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf8Formatter<TResolver> : IJsonFormatter<Guid, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly GuidUtf8Formatter<TResolver> Default = new GuidUtf8Formatter<TResolver>();

        public Guid Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Guid();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid value, int nestingLimit)
        {
            writer.WriteUtf8Guid(value);
        }
    }

    public sealed class NullableGuidUtf8Formatter<TResolver> : IJsonFormatter<Guid?, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableGuidUtf8Formatter<TResolver> Default = new NullableGuidUtf8Formatter<TResolver>();
        private static readonly GuidUtf8Formatter<TResolver> ElementFormatter = GuidUtf8Formatter<TResolver>.Default;

        public Guid? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.Value, nestingLimit);
        }
    }

    public sealed class NullableGuidUtf8ArrayFormatter<TResolver> : IJsonFormatter<Guid?[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableGuidUtf8ArrayFormatter<TResolver> Default = new NullableGuidUtf8ArrayFormatter<TResolver>();
        private static readonly NullableGuidUtf8Formatter<TResolver> ElementFormatter = NullableGuidUtf8Formatter<TResolver>.Default;

        public Guid?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = new Guid?[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableGuidUtf8ListFormatter<TResolver> : IJsonFormatter<List<Guid?>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly NullableGuidUtf8ListFormatter<TResolver> Default = new NullableGuidUtf8ListFormatter<TResolver>();
        private static readonly NullableGuidUtf8Formatter<TResolver> ElementFormatter = NullableGuidUtf8Formatter<TResolver>.Default;

        public List<Guid?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf8ArrayFormatter<TResolver> : IJsonFormatter<Guid[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly GuidUtf8ArrayFormatter<TResolver> Default = new GuidUtf8ArrayFormatter<TResolver>();
        private static readonly GuidUtf8Formatter<TResolver> ElementFormatter = GuidUtf8Formatter<TResolver>.Default;

        public Guid[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = new Guid[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf8ListFormatter<TResolver> : IJsonFormatter<List<Guid>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly GuidUtf8ListFormatter<TResolver> Default = new GuidUtf8ListFormatter<TResolver>();
        private static readonly GuidUtf8Formatter<TResolver> ElementFormatter = GuidUtf8Formatter<TResolver>.Default;

        public List<Guid> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class StringUtf16Formatter<TResolver> : IJsonFormatter<String, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly StringUtf16Formatter<TResolver> Default = new StringUtf16Formatter<TResolver>();

        public String Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16String();
        }

        public void Serialize(ref JsonWriter<Char> writer, String value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16String(value);
        }
    }

    public sealed class StringUtf16ArrayFormatter<TResolver> : IJsonFormatter<String[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly StringUtf16ArrayFormatter<TResolver> Default = new StringUtf16ArrayFormatter<TResolver>();
        private static readonly StringUtf16Formatter<TResolver> ElementFormatter = StringUtf16Formatter<TResolver>.Default;

        public String[] Deserialize(ref JsonReader<Char> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = new String[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, String[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class StringUtf16ListFormatter<TResolver> : IJsonFormatter<List<String>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly StringUtf16ListFormatter<TResolver> Default = new StringUtf16ListFormatter<TResolver>();
        private static readonly StringUtf16Formatter<TResolver> ElementFormatter = StringUtf16Formatter<TResolver>.Default;

        public List<String> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<String> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class StringUtf8Formatter<TResolver> : IJsonFormatter<String, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly StringUtf8Formatter<TResolver> Default = new StringUtf8Formatter<TResolver>();

        public String Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8String();
        }

        public void Serialize(ref JsonWriter<Byte> writer, String value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8String(value);
        }
    }

    public sealed class StringUtf8ArrayFormatter<TResolver> : IJsonFormatter<String[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly StringUtf8ArrayFormatter<TResolver> Default = new StringUtf8ArrayFormatter<TResolver>();
        private static readonly StringUtf8Formatter<TResolver> ElementFormatter = StringUtf8Formatter<TResolver>.Default;

        public String[] Deserialize(ref JsonReader<Byte> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = new String[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, String[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class StringUtf8ListFormatter<TResolver> : IJsonFormatter<List<String>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly StringUtf8ListFormatter<TResolver> Default = new StringUtf8ListFormatter<TResolver>();
        private static readonly StringUtf8Formatter<TResolver> ElementFormatter = StringUtf8Formatter<TResolver>.Default;

        public List<String> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<String> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class VersionUtf16Formatter<TResolver> : IJsonFormatter<Version, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly VersionUtf16Formatter<TResolver> Default = new VersionUtf16Formatter<TResolver>();

        public Version Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Version();
        }

        public void Serialize(ref JsonWriter<Char> writer, Version value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16Version(value);
        }
    }

    public sealed class VersionUtf16ArrayFormatter<TResolver> : IJsonFormatter<Version[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly VersionUtf16ArrayFormatter<TResolver> Default = new VersionUtf16ArrayFormatter<TResolver>();
        private static readonly VersionUtf16Formatter<TResolver> ElementFormatter = VersionUtf16Formatter<TResolver>.Default;

        public Version[] Deserialize(ref JsonReader<Char> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = new Version[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Version[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class VersionUtf16ListFormatter<TResolver> : IJsonFormatter<List<Version>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly VersionUtf16ListFormatter<TResolver> Default = new VersionUtf16ListFormatter<TResolver>();
        private static readonly VersionUtf16Formatter<TResolver> ElementFormatter = VersionUtf16Formatter<TResolver>.Default;

        public List<Version> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Version> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class VersionUtf8Formatter<TResolver> : IJsonFormatter<Version, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly VersionUtf8Formatter<TResolver> Default = new VersionUtf8Formatter<TResolver>();

        public Version Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Version();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Version value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8Version(value);
        }
    }

    public sealed class VersionUtf8ArrayFormatter<TResolver> : IJsonFormatter<Version[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly VersionUtf8ArrayFormatter<TResolver> Default = new VersionUtf8ArrayFormatter<TResolver>();
        private static readonly VersionUtf8Formatter<TResolver> ElementFormatter = VersionUtf8Formatter<TResolver>.Default;

        public Version[] Deserialize(ref JsonReader<Byte> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = new Version[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Version[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class VersionUtf8ListFormatter<TResolver> : IJsonFormatter<List<Version>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly VersionUtf8ListFormatter<TResolver> Default = new VersionUtf8ListFormatter<TResolver>();
        private static readonly VersionUtf8Formatter<TResolver> ElementFormatter = VersionUtf8Formatter<TResolver>.Default;

        public List<Version> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Version> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UriUtf16Formatter<TResolver> : IJsonFormatter<Uri, Char, TResolver> where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UriUtf16Formatter<TResolver> Default = new UriUtf16Formatter<TResolver>();

        public Uri Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Uri();
        }

        public void Serialize(ref JsonWriter<Char> writer, Uri value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16Uri(value);
        }
    }

    public sealed class UriUtf16ArrayFormatter<TResolver> : IJsonFormatter<Uri[], Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UriUtf16ArrayFormatter<TResolver> Default = new UriUtf16ArrayFormatter<TResolver>();
        private static readonly UriUtf16Formatter<TResolver> ElementFormatter = UriUtf16Formatter<TResolver>.Default;

        public Uri[] Deserialize(ref JsonReader<Char> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = new Uri[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Uri[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UriUtf16ListFormatter<TResolver> : IJsonFormatter<List<Uri>, Char, TResolver>
        where TResolver : IJsonFormatterResolver<Char, TResolver>, new()
    {
        public static readonly UriUtf16ListFormatter<TResolver> Default = new UriUtf16ListFormatter<TResolver>();
        private static readonly UriUtf16Formatter<TResolver> ElementFormatter = UriUtf16Formatter<TResolver>.Default;

        public List<Uri> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Uri> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UriUtf8Formatter<TResolver> : IJsonFormatter<Uri, Byte, TResolver> where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UriUtf8Formatter<TResolver> Default = new UriUtf8Formatter<TResolver>();

        public Uri Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Uri();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Uri value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8Uri(value);
        }
    }

    public sealed class UriUtf8ArrayFormatter<TResolver> : IJsonFormatter<Uri[], Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UriUtf8ArrayFormatter<TResolver> Default = new UriUtf8ArrayFormatter<TResolver>();
        private static readonly UriUtf8Formatter<TResolver> ElementFormatter = UriUtf8Formatter<TResolver>.Default;

        public Uri[] Deserialize(ref JsonReader<Byte> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.Grow(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = new Uri[count];
                    Array.Copy(temp, result, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Uri[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UriUtf8ListFormatter<TResolver> : IJsonFormatter<List<Uri>, Byte, TResolver>
        where TResolver : IJsonFormatterResolver<Byte, TResolver>, new()
    {
        public static readonly UriUtf8ListFormatter<TResolver> Default = new UriUtf8ListFormatter<TResolver>();
        private static readonly UriUtf8Formatter<TResolver> ElementFormatter = UriUtf8Formatter<TResolver>.Default;

        public List<Uri> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Uri> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }
}