using System;
using System.Buffers;
using System.Collections.Generic;
using SpanJson.Helpers;

// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters
{
    public sealed class SByteUtf16Formatter : IJsonFormatter<SByte, Char>
    {
        public static readonly SByteUtf16Formatter Default = new SByteUtf16Formatter();

        public SByte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16SByte();
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte value, int nestingLimit)
        {
            writer.WriteUtf16SByte(value);
        }
    }

    public sealed class NullableSByteUtf16Formatter : IJsonFormatter<SByte?, Char>
    {
        public static readonly NullableSByteUtf16Formatter Default = new NullableSByteUtf16Formatter();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;

        public SByte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableSByteUtf16ArrayFormatter : IJsonFormatter<SByte?[], Char>
    {
        public static readonly NullableSByteUtf16ArrayFormatter Default = new NullableSByteUtf16ArrayFormatter();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = NullableSByteUtf16Formatter.Default;

        public SByte?[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableSByteUtf16ListFormatter : IJsonFormatter<List<SByte?>, Char>
    {
        public static readonly NullableSByteUtf16ListFormatter Default = new NullableSByteUtf16ListFormatter();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = NullableSByteUtf16Formatter.Default;

        public List<SByte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<SByte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf16ArrayFormatter : IJsonFormatter<SByte[], Char>
    {
        public static readonly SByteUtf16ArrayFormatter Default = new SByteUtf16ArrayFormatter();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;

        public SByte[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, SByte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf16ListFormatter : IJsonFormatter<List<SByte>, Char>
    {
        public static readonly SByteUtf16ListFormatter Default = new SByteUtf16ListFormatter();
        private static readonly SByteUtf16Formatter ElementFormatter = SByteUtf16Formatter.Default;

        public List<SByte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<SByte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SByteUtf8Formatter : IJsonFormatter<SByte, Byte>
    {
        public static readonly SByteUtf8Formatter Default = new SByteUtf8Formatter();

        public SByte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8SByte();
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte value, int nestingLimit)
        {
            writer.WriteUtf8SByte(value);
        }
    }

    public sealed class NullableSByteUtf8Formatter : IJsonFormatter<SByte?, Byte>
    {
        public static readonly NullableSByteUtf8Formatter Default = new NullableSByteUtf8Formatter();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;

        public SByte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableSByteUtf8ArrayFormatter : IJsonFormatter<SByte?[], Byte>
    {
        public static readonly NullableSByteUtf8ArrayFormatter Default = new NullableSByteUtf8ArrayFormatter();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = NullableSByteUtf8Formatter.Default;

        public SByte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableSByteUtf8ListFormatter : IJsonFormatter<List<SByte?>, Byte>
    {
        public static readonly NullableSByteUtf8ListFormatter Default = new NullableSByteUtf8ListFormatter();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = NullableSByteUtf8Formatter.Default;

        public List<SByte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SByteUtf8ArrayFormatter : IJsonFormatter<SByte[], Byte>
    {
        public static readonly SByteUtf8ArrayFormatter Default = new SByteUtf8ArrayFormatter();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;

        public SByte[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, SByte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SByteUtf8ListFormatter : IJsonFormatter<List<SByte>, Byte>
    {
        public static readonly SByteUtf8ListFormatter Default = new SByteUtf8ListFormatter();
        private static readonly SByteUtf8Formatter ElementFormatter = SByteUtf8Formatter.Default;

        public List<SByte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf16Formatter : IJsonFormatter<Int16, Char>
    {
        public static readonly Int16Utf16Formatter Default = new Int16Utf16Formatter();

        public Int16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int16();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16 value, int nestingLimit)
        {
            writer.WriteUtf16Int16(value);
        }
    }

    public sealed class NullableInt16Utf16Formatter : IJsonFormatter<Int16?, Char>
    {
        public static readonly NullableInt16Utf16Formatter Default = new NullableInt16Utf16Formatter();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;

        public Int16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt16Utf16ArrayFormatter : IJsonFormatter<Int16?[], Char>
    {
        public static readonly NullableInt16Utf16ArrayFormatter Default = new NullableInt16Utf16ArrayFormatter();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = NullableInt16Utf16Formatter.Default;

        public Int16?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt16Utf16ListFormatter : IJsonFormatter<List<Int16?>, Char>
    {
        public static readonly NullableInt16Utf16ListFormatter Default = new NullableInt16Utf16ListFormatter();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = NullableInt16Utf16Formatter.Default;

        public List<Int16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf16ArrayFormatter : IJsonFormatter<Int16[], Char>
    {
        public static readonly Int16Utf16ArrayFormatter Default = new Int16Utf16ArrayFormatter();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;

        public Int16[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf16ListFormatter : IJsonFormatter<List<Int16>, Char>
    {
        public static readonly Int16Utf16ListFormatter Default = new Int16Utf16ListFormatter();
        private static readonly Int16Utf16Formatter ElementFormatter = Int16Utf16Formatter.Default;

        public List<Int16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int16Utf8Formatter : IJsonFormatter<Int16, Byte>
    {
        public static readonly Int16Utf8Formatter Default = new Int16Utf8Formatter();

        public Int16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int16();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16 value, int nestingLimit)
        {
            writer.WriteUtf8Int16(value);
        }
    }

    public sealed class NullableInt16Utf8Formatter : IJsonFormatter<Int16?, Byte>
    {
        public static readonly NullableInt16Utf8Formatter Default = new NullableInt16Utf8Formatter();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;

        public Int16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt16Utf8ArrayFormatter : IJsonFormatter<Int16?[], Byte>
    {
        public static readonly NullableInt16Utf8ArrayFormatter Default = new NullableInt16Utf8ArrayFormatter();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = NullableInt16Utf8Formatter.Default;

        public Int16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt16Utf8ListFormatter : IJsonFormatter<List<Int16?>, Byte>
    {
        public static readonly NullableInt16Utf8ListFormatter Default = new NullableInt16Utf8ListFormatter();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = NullableInt16Utf8Formatter.Default;

        public List<Int16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf8ArrayFormatter : IJsonFormatter<Int16[], Byte>
    {
        public static readonly Int16Utf8ArrayFormatter Default = new Int16Utf8ArrayFormatter();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;

        public Int16[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int16Utf8ListFormatter : IJsonFormatter<List<Int16>, Byte>
    {
        public static readonly Int16Utf8ListFormatter Default = new Int16Utf8ListFormatter();
        private static readonly Int16Utf8Formatter ElementFormatter = Int16Utf8Formatter.Default;

        public List<Int16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf16Formatter : IJsonFormatter<Int32, Char>
    {
        public static readonly Int32Utf16Formatter Default = new Int32Utf16Formatter();

        public Int32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int32();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32 value, int nestingLimit)
        {
            writer.WriteUtf16Int32(value);
        }
    }

    public sealed class NullableInt32Utf16Formatter : IJsonFormatter<Int32?, Char>
    {
        public static readonly NullableInt32Utf16Formatter Default = new NullableInt32Utf16Formatter();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;

        public Int32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt32Utf16ArrayFormatter : IJsonFormatter<Int32?[], Char>
    {
        public static readonly NullableInt32Utf16ArrayFormatter Default = new NullableInt32Utf16ArrayFormatter();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = NullableInt32Utf16Formatter.Default;

        public Int32?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt32Utf16ListFormatter : IJsonFormatter<List<Int32?>, Char>
    {
        public static readonly NullableInt32Utf16ListFormatter Default = new NullableInt32Utf16ListFormatter();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = NullableInt32Utf16Formatter.Default;

        public List<Int32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf16ArrayFormatter : IJsonFormatter<Int32[], Char>
    {
        public static readonly Int32Utf16ArrayFormatter Default = new Int32Utf16ArrayFormatter();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;

        public Int32[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf16ListFormatter : IJsonFormatter<List<Int32>, Char>
    {
        public static readonly Int32Utf16ListFormatter Default = new Int32Utf16ListFormatter();
        private static readonly Int32Utf16Formatter ElementFormatter = Int32Utf16Formatter.Default;

        public List<Int32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int32Utf8Formatter : IJsonFormatter<Int32, Byte>
    {
        public static readonly Int32Utf8Formatter Default = new Int32Utf8Formatter();

        public Int32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int32();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32 value, int nestingLimit)
        {
            writer.WriteUtf8Int32(value);
        }
    }

    public sealed class NullableInt32Utf8Formatter : IJsonFormatter<Int32?, Byte>
    {
        public static readonly NullableInt32Utf8Formatter Default = new NullableInt32Utf8Formatter();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;

        public Int32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt32Utf8ArrayFormatter : IJsonFormatter<Int32?[], Byte>
    {
        public static readonly NullableInt32Utf8ArrayFormatter Default = new NullableInt32Utf8ArrayFormatter();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = NullableInt32Utf8Formatter.Default;

        public Int32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt32Utf8ListFormatter : IJsonFormatter<List<Int32?>, Byte>
    {
        public static readonly NullableInt32Utf8ListFormatter Default = new NullableInt32Utf8ListFormatter();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = NullableInt32Utf8Formatter.Default;

        public List<Int32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf8ArrayFormatter : IJsonFormatter<Int32[], Byte>
    {
        public static readonly Int32Utf8ArrayFormatter Default = new Int32Utf8ArrayFormatter();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;

        public Int32[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int32Utf8ListFormatter : IJsonFormatter<List<Int32>, Byte>
    {
        public static readonly Int32Utf8ListFormatter Default = new Int32Utf8ListFormatter();
        private static readonly Int32Utf8Formatter ElementFormatter = Int32Utf8Formatter.Default;

        public List<Int32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf16Formatter : IJsonFormatter<Int64, Char>
    {
        public static readonly Int64Utf16Formatter Default = new Int64Utf16Formatter();

        public Int64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int64();
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64 value, int nestingLimit)
        {
            writer.WriteUtf16Int64(value);
        }
    }

    public sealed class NullableInt64Utf16Formatter : IJsonFormatter<Int64?, Char>
    {
        public static readonly NullableInt64Utf16Formatter Default = new NullableInt64Utf16Formatter();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;

        public Int64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt64Utf16ArrayFormatter : IJsonFormatter<Int64?[], Char>
    {
        public static readonly NullableInt64Utf16ArrayFormatter Default = new NullableInt64Utf16ArrayFormatter();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = NullableInt64Utf16Formatter.Default;

        public Int64?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableInt64Utf16ListFormatter : IJsonFormatter<List<Int64?>, Char>
    {
        public static readonly NullableInt64Utf16ListFormatter Default = new NullableInt64Utf16ListFormatter();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = NullableInt64Utf16Formatter.Default;

        public List<Int64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf16ArrayFormatter : IJsonFormatter<Int64[], Char>
    {
        public static readonly Int64Utf16ArrayFormatter Default = new Int64Utf16ArrayFormatter();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;

        public Int64[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Int64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf16ListFormatter : IJsonFormatter<List<Int64>, Char>
    {
        public static readonly Int64Utf16ListFormatter Default = new Int64Utf16ListFormatter();
        private static readonly Int64Utf16Formatter ElementFormatter = Int64Utf16Formatter.Default;

        public List<Int64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Int64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class Int64Utf8Formatter : IJsonFormatter<Int64, Byte>
    {
        public static readonly Int64Utf8Formatter Default = new Int64Utf8Formatter();

        public Int64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int64();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64 value, int nestingLimit)
        {
            writer.WriteUtf8Int64(value);
        }
    }

    public sealed class NullableInt64Utf8Formatter : IJsonFormatter<Int64?, Byte>
    {
        public static readonly NullableInt64Utf8Formatter Default = new NullableInt64Utf8Formatter();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;

        public Int64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableInt64Utf8ArrayFormatter : IJsonFormatter<Int64?[], Byte>
    {
        public static readonly NullableInt64Utf8ArrayFormatter Default = new NullableInt64Utf8ArrayFormatter();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = NullableInt64Utf8Formatter.Default;

        public Int64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableInt64Utf8ListFormatter : IJsonFormatter<List<Int64?>, Byte>
    {
        public static readonly NullableInt64Utf8ListFormatter Default = new NullableInt64Utf8ListFormatter();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = NullableInt64Utf8Formatter.Default;

        public List<Int64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf8ArrayFormatter : IJsonFormatter<Int64[], Byte>
    {
        public static readonly Int64Utf8ArrayFormatter Default = new Int64Utf8ArrayFormatter();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;

        public Int64[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Int64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class Int64Utf8ListFormatter : IJsonFormatter<List<Int64>, Byte>
    {
        public static readonly Int64Utf8ListFormatter Default = new Int64Utf8ListFormatter();
        private static readonly Int64Utf8Formatter ElementFormatter = Int64Utf8Formatter.Default;

        public List<Int64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf16Formatter : IJsonFormatter<Byte, Char>
    {
        public static readonly ByteUtf16Formatter Default = new ByteUtf16Formatter();

        public Byte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Byte();
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte value, int nestingLimit)
        {
            writer.WriteUtf16Byte(value);
        }
    }

    public sealed class NullableByteUtf16Formatter : IJsonFormatter<Byte?, Char>
    {
        public static readonly NullableByteUtf16Formatter Default = new NullableByteUtf16Formatter();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;

        public Byte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableByteUtf16ArrayFormatter : IJsonFormatter<Byte?[], Char>
    {
        public static readonly NullableByteUtf16ArrayFormatter Default = new NullableByteUtf16ArrayFormatter();
        private static readonly NullableByteUtf16Formatter ElementFormatter = NullableByteUtf16Formatter.Default;

        public Byte?[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableByteUtf16ListFormatter : IJsonFormatter<List<Byte?>, Char>
    {
        public static readonly NullableByteUtf16ListFormatter Default = new NullableByteUtf16ListFormatter();
        private static readonly NullableByteUtf16Formatter ElementFormatter = NullableByteUtf16Formatter.Default;

        public List<Byte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Byte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf16ArrayFormatter : IJsonFormatter<Byte[], Char>
    {
        public static readonly ByteUtf16ArrayFormatter Default = new ByteUtf16ArrayFormatter();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;

        public Byte[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Byte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf16ListFormatter : IJsonFormatter<List<Byte>, Char>
    {
        public static readonly ByteUtf16ListFormatter Default = new ByteUtf16ListFormatter();
        private static readonly ByteUtf16Formatter ElementFormatter = ByteUtf16Formatter.Default;

        public List<Byte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Byte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class ByteUtf8Formatter : IJsonFormatter<Byte, Byte>
    {
        public static readonly ByteUtf8Formatter Default = new ByteUtf8Formatter();

        public Byte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Byte();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte value, int nestingLimit)
        {
            writer.WriteUtf8Byte(value);
        }
    }

    public sealed class NullableByteUtf8Formatter : IJsonFormatter<Byte?, Byte>
    {
        public static readonly NullableByteUtf8Formatter Default = new NullableByteUtf8Formatter();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;

        public Byte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableByteUtf8ArrayFormatter : IJsonFormatter<Byte?[], Byte>
    {
        public static readonly NullableByteUtf8ArrayFormatter Default = new NullableByteUtf8ArrayFormatter();
        private static readonly NullableByteUtf8Formatter ElementFormatter = NullableByteUtf8Formatter.Default;

        public Byte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableByteUtf8ListFormatter : IJsonFormatter<List<Byte?>, Byte>
    {
        public static readonly NullableByteUtf8ListFormatter Default = new NullableByteUtf8ListFormatter();
        private static readonly NullableByteUtf8Formatter ElementFormatter = NullableByteUtf8Formatter.Default;

        public List<Byte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf8ArrayFormatter : IJsonFormatter<Byte[], Byte>
    {
        public static readonly ByteUtf8ArrayFormatter Default = new ByteUtf8ArrayFormatter();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;

        public Byte[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Byte[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class ByteUtf8ListFormatter : IJsonFormatter<List<Byte>, Byte>
    {
        public static readonly ByteUtf8ListFormatter Default = new ByteUtf8ListFormatter();
        private static readonly ByteUtf8Formatter ElementFormatter = ByteUtf8Formatter.Default;

        public List<Byte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf16Formatter : IJsonFormatter<UInt16, Char>
    {
        public static readonly UInt16Utf16Formatter Default = new UInt16Utf16Formatter();

        public UInt16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt16();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16 value, int nestingLimit)
        {
            writer.WriteUtf16UInt16(value);
        }
    }

    public sealed class NullableUInt16Utf16Formatter : IJsonFormatter<UInt16?, Char>
    {
        public static readonly NullableUInt16Utf16Formatter Default = new NullableUInt16Utf16Formatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;

        public UInt16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt16Utf16ArrayFormatter : IJsonFormatter<UInt16?[], Char>
    {
        public static readonly NullableUInt16Utf16ArrayFormatter Default = new NullableUInt16Utf16ArrayFormatter();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = NullableUInt16Utf16Formatter.Default;

        public UInt16?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt16Utf16ListFormatter : IJsonFormatter<List<UInt16?>, Char>
    {
        public static readonly NullableUInt16Utf16ListFormatter Default = new NullableUInt16Utf16ListFormatter();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = NullableUInt16Utf16Formatter.Default;

        public List<UInt16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf16ArrayFormatter : IJsonFormatter<UInt16[], Char>
    {
        public static readonly UInt16Utf16ArrayFormatter Default = new UInt16Utf16ArrayFormatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;

        public UInt16[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf16ListFormatter : IJsonFormatter<List<UInt16>, Char>
    {
        public static readonly UInt16Utf16ListFormatter Default = new UInt16Utf16ListFormatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = UInt16Utf16Formatter.Default;

        public List<UInt16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt16Utf8Formatter : IJsonFormatter<UInt16, Byte>
    {
        public static readonly UInt16Utf8Formatter Default = new UInt16Utf8Formatter();

        public UInt16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt16();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16 value, int nestingLimit)
        {
            writer.WriteUtf8UInt16(value);
        }
    }

    public sealed class NullableUInt16Utf8Formatter : IJsonFormatter<UInt16?, Byte>
    {
        public static readonly NullableUInt16Utf8Formatter Default = new NullableUInt16Utf8Formatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;

        public UInt16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt16Utf8ArrayFormatter : IJsonFormatter<UInt16?[], Byte>
    {
        public static readonly NullableUInt16Utf8ArrayFormatter Default = new NullableUInt16Utf8ArrayFormatter();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = NullableUInt16Utf8Formatter.Default;

        public UInt16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt16Utf8ListFormatter : IJsonFormatter<List<UInt16?>, Byte>
    {
        public static readonly NullableUInt16Utf8ListFormatter Default = new NullableUInt16Utf8ListFormatter();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = NullableUInt16Utf8Formatter.Default;

        public List<UInt16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf8ArrayFormatter : IJsonFormatter<UInt16[], Byte>
    {
        public static readonly UInt16Utf8ArrayFormatter Default = new UInt16Utf8ArrayFormatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;

        public UInt16[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt16[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt16Utf8ListFormatter : IJsonFormatter<List<UInt16>, Byte>
    {
        public static readonly UInt16Utf8ListFormatter Default = new UInt16Utf8ListFormatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = UInt16Utf8Formatter.Default;

        public List<UInt16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf16Formatter : IJsonFormatter<UInt32, Char>
    {
        public static readonly UInt32Utf16Formatter Default = new UInt32Utf16Formatter();

        public UInt32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt32();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32 value, int nestingLimit)
        {
            writer.WriteUtf16UInt32(value);
        }
    }

    public sealed class NullableUInt32Utf16Formatter : IJsonFormatter<UInt32?, Char>
    {
        public static readonly NullableUInt32Utf16Formatter Default = new NullableUInt32Utf16Formatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;

        public UInt32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt32Utf16ArrayFormatter : IJsonFormatter<UInt32?[], Char>
    {
        public static readonly NullableUInt32Utf16ArrayFormatter Default = new NullableUInt32Utf16ArrayFormatter();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = NullableUInt32Utf16Formatter.Default;

        public UInt32?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt32Utf16ListFormatter : IJsonFormatter<List<UInt32?>, Char>
    {
        public static readonly NullableUInt32Utf16ListFormatter Default = new NullableUInt32Utf16ListFormatter();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = NullableUInt32Utf16Formatter.Default;

        public List<UInt32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf16ArrayFormatter : IJsonFormatter<UInt32[], Char>
    {
        public static readonly UInt32Utf16ArrayFormatter Default = new UInt32Utf16ArrayFormatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;

        public UInt32[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf16ListFormatter : IJsonFormatter<List<UInt32>, Char>
    {
        public static readonly UInt32Utf16ListFormatter Default = new UInt32Utf16ListFormatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = UInt32Utf16Formatter.Default;

        public List<UInt32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt32Utf8Formatter : IJsonFormatter<UInt32, Byte>
    {
        public static readonly UInt32Utf8Formatter Default = new UInt32Utf8Formatter();

        public UInt32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt32();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32 value, int nestingLimit)
        {
            writer.WriteUtf8UInt32(value);
        }
    }

    public sealed class NullableUInt32Utf8Formatter : IJsonFormatter<UInt32?, Byte>
    {
        public static readonly NullableUInt32Utf8Formatter Default = new NullableUInt32Utf8Formatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;

        public UInt32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt32Utf8ArrayFormatter : IJsonFormatter<UInt32?[], Byte>
    {
        public static readonly NullableUInt32Utf8ArrayFormatter Default = new NullableUInt32Utf8ArrayFormatter();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = NullableUInt32Utf8Formatter.Default;

        public UInt32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt32Utf8ListFormatter : IJsonFormatter<List<UInt32?>, Byte>
    {
        public static readonly NullableUInt32Utf8ListFormatter Default = new NullableUInt32Utf8ListFormatter();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = NullableUInt32Utf8Formatter.Default;

        public List<UInt32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf8ArrayFormatter : IJsonFormatter<UInt32[], Byte>
    {
        public static readonly UInt32Utf8ArrayFormatter Default = new UInt32Utf8ArrayFormatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;

        public UInt32[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt32[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt32Utf8ListFormatter : IJsonFormatter<List<UInt32>, Byte>
    {
        public static readonly UInt32Utf8ListFormatter Default = new UInt32Utf8ListFormatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = UInt32Utf8Formatter.Default;

        public List<UInt32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf16Formatter : IJsonFormatter<UInt64, Char>
    {
        public static readonly UInt64Utf16Formatter Default = new UInt64Utf16Formatter();

        public UInt64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt64();
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64 value, int nestingLimit)
        {
            writer.WriteUtf16UInt64(value);
        }
    }

    public sealed class NullableUInt64Utf16Formatter : IJsonFormatter<UInt64?, Char>
    {
        public static readonly NullableUInt64Utf16Formatter Default = new NullableUInt64Utf16Formatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;

        public UInt64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt64Utf16ArrayFormatter : IJsonFormatter<UInt64?[], Char>
    {
        public static readonly NullableUInt64Utf16ArrayFormatter Default = new NullableUInt64Utf16ArrayFormatter();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = NullableUInt64Utf16Formatter.Default;

        public UInt64?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableUInt64Utf16ListFormatter : IJsonFormatter<List<UInt64?>, Char>
    {
        public static readonly NullableUInt64Utf16ListFormatter Default = new NullableUInt64Utf16ListFormatter();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = NullableUInt64Utf16Formatter.Default;

        public List<UInt64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf16ArrayFormatter : IJsonFormatter<UInt64[], Char>
    {
        public static readonly UInt64Utf16ArrayFormatter Default = new UInt64Utf16ArrayFormatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;

        public UInt64[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, UInt64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf16ListFormatter : IJsonFormatter<List<UInt64>, Char>
    {
        public static readonly UInt64Utf16ListFormatter Default = new UInt64Utf16ListFormatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = UInt64Utf16Formatter.Default;

        public List<UInt64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UInt64Utf8Formatter : IJsonFormatter<UInt64, Byte>
    {
        public static readonly UInt64Utf8Formatter Default = new UInt64Utf8Formatter();

        public UInt64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt64();
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64 value, int nestingLimit)
        {
            writer.WriteUtf8UInt64(value);
        }
    }

    public sealed class NullableUInt64Utf8Formatter : IJsonFormatter<UInt64?, Byte>
    {
        public static readonly NullableUInt64Utf8Formatter Default = new NullableUInt64Utf8Formatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;

        public UInt64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableUInt64Utf8ArrayFormatter : IJsonFormatter<UInt64?[], Byte>
    {
        public static readonly NullableUInt64Utf8ArrayFormatter Default = new NullableUInt64Utf8ArrayFormatter();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = NullableUInt64Utf8Formatter.Default;

        public UInt64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableUInt64Utf8ListFormatter : IJsonFormatter<List<UInt64?>, Byte>
    {
        public static readonly NullableUInt64Utf8ListFormatter Default = new NullableUInt64Utf8ListFormatter();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = NullableUInt64Utf8Formatter.Default;

        public List<UInt64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf8ArrayFormatter : IJsonFormatter<UInt64[], Byte>
    {
        public static readonly UInt64Utf8ArrayFormatter Default = new UInt64Utf8ArrayFormatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;

        public UInt64[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, UInt64[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UInt64Utf8ListFormatter : IJsonFormatter<List<UInt64>, Byte>
    {
        public static readonly UInt64Utf8ListFormatter Default = new UInt64Utf8ListFormatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = UInt64Utf8Formatter.Default;

        public List<UInt64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf16Formatter : IJsonFormatter<Single, Char>
    {
        public static readonly SingleUtf16Formatter Default = new SingleUtf16Formatter();

        public Single Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Single();
        }

        public void Serialize(ref JsonWriter<Char> writer, Single value, int nestingLimit)
        {
            writer.WriteUtf16Single(value);
        }
    }

    public sealed class NullableSingleUtf16Formatter : IJsonFormatter<Single?, Char>
    {
        public static readonly NullableSingleUtf16Formatter Default = new NullableSingleUtf16Formatter();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;

        public Single? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Single? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableSingleUtf16ArrayFormatter : IJsonFormatter<Single?[], Char>
    {
        public static readonly NullableSingleUtf16ArrayFormatter Default = new NullableSingleUtf16ArrayFormatter();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = NullableSingleUtf16Formatter.Default;

        public Single?[] Deserialize(ref JsonReader<Char> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Single?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableSingleUtf16ListFormatter : IJsonFormatter<List<Single?>, Char>
    {
        public static readonly NullableSingleUtf16ListFormatter Default = new NullableSingleUtf16ListFormatter();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = NullableSingleUtf16Formatter.Default;

        public List<Single?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Single?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf16ArrayFormatter : IJsonFormatter<Single[], Char>
    {
        public static readonly SingleUtf16ArrayFormatter Default = new SingleUtf16ArrayFormatter();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;

        public Single[] Deserialize(ref JsonReader<Char> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Single[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf16ListFormatter : IJsonFormatter<List<Single>, Char>
    {
        public static readonly SingleUtf16ListFormatter Default = new SingleUtf16ListFormatter();
        private static readonly SingleUtf16Formatter ElementFormatter = SingleUtf16Formatter.Default;

        public List<Single> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Single> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class SingleUtf8Formatter : IJsonFormatter<Single, Byte>
    {
        public static readonly SingleUtf8Formatter Default = new SingleUtf8Formatter();

        public Single Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Single();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single value, int nestingLimit)
        {
            writer.WriteUtf8Single(value);
        }
    }

    public sealed class NullableSingleUtf8Formatter : IJsonFormatter<Single?, Byte>
    {
        public static readonly NullableSingleUtf8Formatter Default = new NullableSingleUtf8Formatter();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;

        public Single? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableSingleUtf8ArrayFormatter : IJsonFormatter<Single?[], Byte>
    {
        public static readonly NullableSingleUtf8ArrayFormatter Default = new NullableSingleUtf8ArrayFormatter();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = NullableSingleUtf8Formatter.Default;

        public Single?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableSingleUtf8ListFormatter : IJsonFormatter<List<Single?>, Byte>
    {
        public static readonly NullableSingleUtf8ListFormatter Default = new NullableSingleUtf8ListFormatter();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = NullableSingleUtf8Formatter.Default;

        public List<Single?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Single?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf8ArrayFormatter : IJsonFormatter<Single[], Byte>
    {
        public static readonly SingleUtf8ArrayFormatter Default = new SingleUtf8ArrayFormatter();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;

        public Single[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Single[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class SingleUtf8ListFormatter : IJsonFormatter<List<Single>, Byte>
    {
        public static readonly SingleUtf8ListFormatter Default = new SingleUtf8ListFormatter();
        private static readonly SingleUtf8Formatter ElementFormatter = SingleUtf8Formatter.Default;

        public List<Single> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Single> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf16Formatter : IJsonFormatter<Double, Char>
    {
        public static readonly DoubleUtf16Formatter Default = new DoubleUtf16Formatter();

        public Double Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Double();
        }

        public void Serialize(ref JsonWriter<Char> writer, Double value, int nestingLimit)
        {
            writer.WriteUtf16Double(value);
        }
    }

    public sealed class NullableDoubleUtf16Formatter : IJsonFormatter<Double?, Char>
    {
        public static readonly NullableDoubleUtf16Formatter Default = new NullableDoubleUtf16Formatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;

        public Double? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Double? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDoubleUtf16ArrayFormatter : IJsonFormatter<Double?[], Char>
    {
        public static readonly NullableDoubleUtf16ArrayFormatter Default = new NullableDoubleUtf16ArrayFormatter();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = NullableDoubleUtf16Formatter.Default;

        public Double?[] Deserialize(ref JsonReader<Char> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Double?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDoubleUtf16ListFormatter : IJsonFormatter<List<Double?>, Char>
    {
        public static readonly NullableDoubleUtf16ListFormatter Default = new NullableDoubleUtf16ListFormatter();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = NullableDoubleUtf16Formatter.Default;

        public List<Double?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Double?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf16ArrayFormatter : IJsonFormatter<Double[], Char>
    {
        public static readonly DoubleUtf16ArrayFormatter Default = new DoubleUtf16ArrayFormatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;

        public Double[] Deserialize(ref JsonReader<Char> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Double[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf16ListFormatter : IJsonFormatter<List<Double>, Char>
    {
        public static readonly DoubleUtf16ListFormatter Default = new DoubleUtf16ListFormatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = DoubleUtf16Formatter.Default;

        public List<Double> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Double> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DoubleUtf8Formatter : IJsonFormatter<Double, Byte>
    {
        public static readonly DoubleUtf8Formatter Default = new DoubleUtf8Formatter();

        public Double Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Double();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double value, int nestingLimit)
        {
            writer.WriteUtf8Double(value);
        }
    }

    public sealed class NullableDoubleUtf8Formatter : IJsonFormatter<Double?, Byte>
    {
        public static readonly NullableDoubleUtf8Formatter Default = new NullableDoubleUtf8Formatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;

        public Double? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDoubleUtf8ArrayFormatter : IJsonFormatter<Double?[], Byte>
    {
        public static readonly NullableDoubleUtf8ArrayFormatter Default = new NullableDoubleUtf8ArrayFormatter();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = NullableDoubleUtf8Formatter.Default;

        public Double?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDoubleUtf8ListFormatter : IJsonFormatter<List<Double?>, Byte>
    {
        public static readonly NullableDoubleUtf8ListFormatter Default = new NullableDoubleUtf8ListFormatter();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = NullableDoubleUtf8Formatter.Default;

        public List<Double?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Double?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf8ArrayFormatter : IJsonFormatter<Double[], Byte>
    {
        public static readonly DoubleUtf8ArrayFormatter Default = new DoubleUtf8ArrayFormatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;

        public Double[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Double[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DoubleUtf8ListFormatter : IJsonFormatter<List<Double>, Byte>
    {
        public static readonly DoubleUtf8ListFormatter Default = new DoubleUtf8ListFormatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = DoubleUtf8Formatter.Default;

        public List<Double> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Double> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf16Formatter : IJsonFormatter<Decimal, Char>
    {
        public static readonly DecimalUtf16Formatter Default = new DecimalUtf16Formatter();

        public Decimal Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Decimal();
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal value, int nestingLimit)
        {
            writer.WriteUtf16Decimal(value);
        }
    }

    public sealed class NullableDecimalUtf16Formatter : IJsonFormatter<Decimal?, Char>
    {
        public static readonly NullableDecimalUtf16Formatter Default = new NullableDecimalUtf16Formatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;

        public Decimal? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDecimalUtf16ArrayFormatter : IJsonFormatter<Decimal?[], Char>
    {
        public static readonly NullableDecimalUtf16ArrayFormatter Default = new NullableDecimalUtf16ArrayFormatter();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = NullableDecimalUtf16Formatter.Default;

        public Decimal?[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDecimalUtf16ListFormatter : IJsonFormatter<List<Decimal?>, Char>
    {
        public static readonly NullableDecimalUtf16ListFormatter Default = new NullableDecimalUtf16ListFormatter();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = NullableDecimalUtf16Formatter.Default;

        public List<Decimal?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf16ArrayFormatter : IJsonFormatter<Decimal[], Char>
    {
        public static readonly DecimalUtf16ArrayFormatter Default = new DecimalUtf16ArrayFormatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;

        public Decimal[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Decimal[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf16ListFormatter : IJsonFormatter<List<Decimal>, Char>
    {
        public static readonly DecimalUtf16ListFormatter Default = new DecimalUtf16ListFormatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = DecimalUtf16Formatter.Default;

        public List<Decimal> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DecimalUtf8Formatter : IJsonFormatter<Decimal, Byte>
    {
        public static readonly DecimalUtf8Formatter Default = new DecimalUtf8Formatter();

        public Decimal Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Decimal();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal value, int nestingLimit)
        {
            writer.WriteUtf8Decimal(value);
        }
    }

    public sealed class NullableDecimalUtf8Formatter : IJsonFormatter<Decimal?, Byte>
    {
        public static readonly NullableDecimalUtf8Formatter Default = new NullableDecimalUtf8Formatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;

        public Decimal? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDecimalUtf8ArrayFormatter : IJsonFormatter<Decimal?[], Byte>
    {
        public static readonly NullableDecimalUtf8ArrayFormatter Default = new NullableDecimalUtf8ArrayFormatter();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = NullableDecimalUtf8Formatter.Default;

        public Decimal?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDecimalUtf8ListFormatter : IJsonFormatter<List<Decimal?>, Byte>
    {
        public static readonly NullableDecimalUtf8ListFormatter Default = new NullableDecimalUtf8ListFormatter();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = NullableDecimalUtf8Formatter.Default;

        public List<Decimal?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf8ArrayFormatter : IJsonFormatter<Decimal[], Byte>
    {
        public static readonly DecimalUtf8ArrayFormatter Default = new DecimalUtf8ArrayFormatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;

        public Decimal[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Decimal[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DecimalUtf8ListFormatter : IJsonFormatter<List<Decimal>, Byte>
    {
        public static readonly DecimalUtf8ListFormatter Default = new DecimalUtf8ListFormatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = DecimalUtf8Formatter.Default;

        public List<Decimal> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf16Formatter : IJsonFormatter<Boolean, Char>
    {
        public static readonly BooleanUtf16Formatter Default = new BooleanUtf16Formatter();

        public Boolean Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Boolean();
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean value, int nestingLimit)
        {
            writer.WriteUtf16Boolean(value);
        }
    }

    public sealed class NullableBooleanUtf16Formatter : IJsonFormatter<Boolean?, Char>
    {
        public static readonly NullableBooleanUtf16Formatter Default = new NullableBooleanUtf16Formatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;

        public Boolean? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableBooleanUtf16ArrayFormatter : IJsonFormatter<Boolean?[], Char>
    {
        public static readonly NullableBooleanUtf16ArrayFormatter Default = new NullableBooleanUtf16ArrayFormatter();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = NullableBooleanUtf16Formatter.Default;

        public Boolean?[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableBooleanUtf16ListFormatter : IJsonFormatter<List<Boolean?>, Char>
    {
        public static readonly NullableBooleanUtf16ListFormatter Default = new NullableBooleanUtf16ListFormatter();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = NullableBooleanUtf16Formatter.Default;

        public List<Boolean?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf16ArrayFormatter : IJsonFormatter<Boolean[], Char>
    {
        public static readonly BooleanUtf16ArrayFormatter Default = new BooleanUtf16ArrayFormatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;

        public Boolean[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Boolean[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf16ListFormatter : IJsonFormatter<List<Boolean>, Char>
    {
        public static readonly BooleanUtf16ListFormatter Default = new BooleanUtf16ListFormatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = BooleanUtf16Formatter.Default;

        public List<Boolean> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class BooleanUtf8Formatter : IJsonFormatter<Boolean, Byte>
    {
        public static readonly BooleanUtf8Formatter Default = new BooleanUtf8Formatter();

        public Boolean Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Boolean();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean value, int nestingLimit)
        {
            writer.WriteUtf8Boolean(value);
        }
    }

    public sealed class NullableBooleanUtf8Formatter : IJsonFormatter<Boolean?, Byte>
    {
        public static readonly NullableBooleanUtf8Formatter Default = new NullableBooleanUtf8Formatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;

        public Boolean? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableBooleanUtf8ArrayFormatter : IJsonFormatter<Boolean?[], Byte>
    {
        public static readonly NullableBooleanUtf8ArrayFormatter Default = new NullableBooleanUtf8ArrayFormatter();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = NullableBooleanUtf8Formatter.Default;

        public Boolean?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableBooleanUtf8ListFormatter : IJsonFormatter<List<Boolean?>, Byte>
    {
        public static readonly NullableBooleanUtf8ListFormatter Default = new NullableBooleanUtf8ListFormatter();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = NullableBooleanUtf8Formatter.Default;

        public List<Boolean?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf8ArrayFormatter : IJsonFormatter<Boolean[], Byte>
    {
        public static readonly BooleanUtf8ArrayFormatter Default = new BooleanUtf8ArrayFormatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;

        public Boolean[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Boolean[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class BooleanUtf8ListFormatter : IJsonFormatter<List<Boolean>, Byte>
    {
        public static readonly BooleanUtf8ListFormatter Default = new BooleanUtf8ListFormatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = BooleanUtf8Formatter.Default;

        public List<Boolean> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf16Formatter : IJsonFormatter<Char, Char>
    {
        public static readonly CharUtf16Formatter Default = new CharUtf16Formatter();

        public Char Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Char();
        }

        public void Serialize(ref JsonWriter<Char> writer, Char value, int nestingLimit)
        {
            writer.WriteUtf16Char(value);
        }
    }

    public sealed class NullableCharUtf16Formatter : IJsonFormatter<Char?, Char>
    {
        public static readonly NullableCharUtf16Formatter Default = new NullableCharUtf16Formatter();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;

        public Char? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Char? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableCharUtf16ArrayFormatter : IJsonFormatter<Char?[], Char>
    {
        public static readonly NullableCharUtf16ArrayFormatter Default = new NullableCharUtf16ArrayFormatter();
        private static readonly NullableCharUtf16Formatter ElementFormatter = NullableCharUtf16Formatter.Default;

        public Char?[] Deserialize(ref JsonReader<Char> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Char?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableCharUtf16ListFormatter : IJsonFormatter<List<Char?>, Char>
    {
        public static readonly NullableCharUtf16ListFormatter Default = new NullableCharUtf16ListFormatter();
        private static readonly NullableCharUtf16Formatter ElementFormatter = NullableCharUtf16Formatter.Default;

        public List<Char?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Char?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf16ArrayFormatter : IJsonFormatter<Char[], Char>
    {
        public static readonly CharUtf16ArrayFormatter Default = new CharUtf16ArrayFormatter();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;

        public Char[] Deserialize(ref JsonReader<Char> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Char[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf16ListFormatter : IJsonFormatter<List<Char>, Char>
    {
        public static readonly CharUtf16ListFormatter Default = new CharUtf16ListFormatter();
        private static readonly CharUtf16Formatter ElementFormatter = CharUtf16Formatter.Default;

        public List<Char> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Char> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class CharUtf8Formatter : IJsonFormatter<Char, Byte>
    {
        public static readonly CharUtf8Formatter Default = new CharUtf8Formatter();

        public Char Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Char();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char value, int nestingLimit)
        {
            writer.WriteUtf8Char(value);
        }
    }

    public sealed class NullableCharUtf8Formatter : IJsonFormatter<Char?, Byte>
    {
        public static readonly NullableCharUtf8Formatter Default = new NullableCharUtf8Formatter();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;

        public Char? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableCharUtf8ArrayFormatter : IJsonFormatter<Char?[], Byte>
    {
        public static readonly NullableCharUtf8ArrayFormatter Default = new NullableCharUtf8ArrayFormatter();
        private static readonly NullableCharUtf8Formatter ElementFormatter = NullableCharUtf8Formatter.Default;

        public Char?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableCharUtf8ListFormatter : IJsonFormatter<List<Char?>, Byte>
    {
        public static readonly NullableCharUtf8ListFormatter Default = new NullableCharUtf8ListFormatter();
        private static readonly NullableCharUtf8Formatter ElementFormatter = NullableCharUtf8Formatter.Default;

        public List<Char?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Char?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf8ArrayFormatter : IJsonFormatter<Char[], Byte>
    {
        public static readonly CharUtf8ArrayFormatter Default = new CharUtf8ArrayFormatter();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;

        public Char[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Char[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class CharUtf8ListFormatter : IJsonFormatter<List<Char>, Byte>
    {
        public static readonly CharUtf8ListFormatter Default = new CharUtf8ListFormatter();
        private static readonly CharUtf8Formatter ElementFormatter = CharUtf8Formatter.Default;

        public List<Char> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Char> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf16Formatter : IJsonFormatter<DateTime, Char>
    {
        public static readonly DateTimeUtf16Formatter Default = new DateTimeUtf16Formatter();

        public DateTime Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTime();
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime value, int nestingLimit)
        {
            writer.WriteUtf16DateTime(value);
        }
    }

    public sealed class NullableDateTimeUtf16Formatter : IJsonFormatter<DateTime?, Char>
    {
        public static readonly NullableDateTimeUtf16Formatter Default = new NullableDateTimeUtf16Formatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;

        public DateTime? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime?[], Char>
    {
        public static readonly NullableDateTimeUtf16ArrayFormatter Default = new NullableDateTimeUtf16ArrayFormatter();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = NullableDateTimeUtf16Formatter.Default;

        public DateTime?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime?>, Char>
    {
        public static readonly NullableDateTimeUtf16ListFormatter Default = new NullableDateTimeUtf16ListFormatter();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = NullableDateTimeUtf16Formatter.Default;

        public List<DateTime?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime[], Char>
    {
        public static readonly DateTimeUtf16ArrayFormatter Default = new DateTimeUtf16ArrayFormatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;

        public DateTime[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTime[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime>, Char>
    {
        public static readonly DateTimeUtf16ListFormatter Default = new DateTimeUtf16ListFormatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = DateTimeUtf16Formatter.Default;

        public List<DateTime> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeUtf8Formatter : IJsonFormatter<DateTime, Byte>
    {
        public static readonly DateTimeUtf8Formatter Default = new DateTimeUtf8Formatter();

        public DateTime Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTime();
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime value, int nestingLimit)
        {
            writer.WriteUtf8DateTime(value);
        }
    }

    public sealed class NullableDateTimeUtf8Formatter : IJsonFormatter<DateTime?, Byte>
    {
        public static readonly NullableDateTimeUtf8Formatter Default = new NullableDateTimeUtf8Formatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;

        public DateTime? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime?[], Byte>
    {
        public static readonly NullableDateTimeUtf8ArrayFormatter Default = new NullableDateTimeUtf8ArrayFormatter();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = NullableDateTimeUtf8Formatter.Default;

        public DateTime?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime?>, Byte>
    {
        public static readonly NullableDateTimeUtf8ListFormatter Default = new NullableDateTimeUtf8ListFormatter();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = NullableDateTimeUtf8Formatter.Default;

        public List<DateTime?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime[], Byte>
    {
        public static readonly DateTimeUtf8ArrayFormatter Default = new DateTimeUtf8ArrayFormatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;

        public DateTime[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTime[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime>, Byte>
    {
        public static readonly DateTimeUtf8ListFormatter Default = new DateTimeUtf8ListFormatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = DateTimeUtf8Formatter.Default;

        public List<DateTime> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset, Char>
    {
        public static readonly DateTimeOffsetUtf16Formatter Default = new DateTimeOffsetUtf16Formatter();

        public DateTimeOffset Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTimeOffset();
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset value, int nestingLimit)
        {
            writer.WriteUtf16DateTimeOffset(value);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset?, Char>
    {
        public static readonly NullableDateTimeOffsetUtf16Formatter Default = new NullableDateTimeOffsetUtf16Formatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;

        public DateTimeOffset? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset?[], Char>
    {
        public static readonly NullableDateTimeOffsetUtf16ArrayFormatter Default = new NullableDateTimeOffsetUtf16ArrayFormatter();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = NullableDateTimeOffsetUtf16Formatter.Default;

        public DateTimeOffset?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset?>, Char>
    {
        public static readonly NullableDateTimeOffsetUtf16ListFormatter Default = new NullableDateTimeOffsetUtf16ListFormatter();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = NullableDateTimeOffsetUtf16Formatter.Default;

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset[], Char>
    {
        public static readonly DateTimeOffsetUtf16ArrayFormatter Default = new DateTimeOffsetUtf16ArrayFormatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;

        public DateTimeOffset[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset>, Char>
    {
        public static readonly DateTimeOffsetUtf16ListFormatter Default = new DateTimeOffsetUtf16ListFormatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = DateTimeOffsetUtf16Formatter.Default;

        public List<DateTimeOffset> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset, Byte>
    {
        public static readonly DateTimeOffsetUtf8Formatter Default = new DateTimeOffsetUtf8Formatter();

        public DateTimeOffset Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTimeOffset();
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset value, int nestingLimit)
        {
            writer.WriteUtf8DateTimeOffset(value);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset?, Byte>
    {
        public static readonly NullableDateTimeOffsetUtf8Formatter Default = new NullableDateTimeOffsetUtf8Formatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;

        public DateTimeOffset? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset?[], Byte>
    {
        public static readonly NullableDateTimeOffsetUtf8ArrayFormatter Default = new NullableDateTimeOffsetUtf8ArrayFormatter();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = NullableDateTimeOffsetUtf8Formatter.Default;

        public DateTimeOffset?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset?>, Byte>
    {
        public static readonly NullableDateTimeOffsetUtf8ListFormatter Default = new NullableDateTimeOffsetUtf8ListFormatter();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = NullableDateTimeOffsetUtf8Formatter.Default;

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset[], Byte>
    {
        public static readonly DateTimeOffsetUtf8ArrayFormatter Default = new DateTimeOffsetUtf8ArrayFormatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;

        public DateTimeOffset[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class DateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset>, Byte>
    {
        public static readonly DateTimeOffsetUtf8ListFormatter Default = new DateTimeOffsetUtf8ListFormatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = DateTimeOffsetUtf8Formatter.Default;

        public List<DateTimeOffset> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf16Formatter : IJsonFormatter<TimeSpan, Char>
    {
        public static readonly TimeSpanUtf16Formatter Default = new TimeSpanUtf16Formatter();

        public TimeSpan Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16TimeSpan();
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan value, int nestingLimit)
        {
            writer.WriteUtf16TimeSpan(value);
        }
    }

    public sealed class NullableTimeSpanUtf16Formatter : IJsonFormatter<TimeSpan?, Char>
    {
        public static readonly NullableTimeSpanUtf16Formatter Default = new NullableTimeSpanUtf16Formatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;

        public TimeSpan? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableTimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan?[], Char>
    {
        public static readonly NullableTimeSpanUtf16ArrayFormatter Default = new NullableTimeSpanUtf16ArrayFormatter();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = NullableTimeSpanUtf16Formatter.Default;

        public TimeSpan?[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableTimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan?>, Char>
    {
        public static readonly NullableTimeSpanUtf16ListFormatter Default = new NullableTimeSpanUtf16ListFormatter();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = NullableTimeSpanUtf16Formatter.Default;

        public List<TimeSpan?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan[], Char>
    {
        public static readonly TimeSpanUtf16ArrayFormatter Default = new TimeSpanUtf16ArrayFormatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;

        public TimeSpan[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan>, Char>
    {
        public static readonly TimeSpanUtf16ListFormatter Default = new TimeSpanUtf16ListFormatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = TimeSpanUtf16Formatter.Default;

        public List<TimeSpan> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class TimeSpanUtf8Formatter : IJsonFormatter<TimeSpan, Byte>
    {
        public static readonly TimeSpanUtf8Formatter Default = new TimeSpanUtf8Formatter();

        public TimeSpan Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8TimeSpan();
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan value, int nestingLimit)
        {
            writer.WriteUtf8TimeSpan(value);
        }
    }

    public sealed class NullableTimeSpanUtf8Formatter : IJsonFormatter<TimeSpan?, Byte>
    {
        public static readonly NullableTimeSpanUtf8Formatter Default = new NullableTimeSpanUtf8Formatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;

        public TimeSpan? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableTimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan?[], Byte>
    {
        public static readonly NullableTimeSpanUtf8ArrayFormatter Default = new NullableTimeSpanUtf8ArrayFormatter();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = NullableTimeSpanUtf8Formatter.Default;

        public TimeSpan?[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableTimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan?>, Byte>
    {
        public static readonly NullableTimeSpanUtf8ListFormatter Default = new NullableTimeSpanUtf8ListFormatter();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = NullableTimeSpanUtf8Formatter.Default;

        public List<TimeSpan?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan[], Byte>
    {
        public static readonly TimeSpanUtf8ArrayFormatter Default = new TimeSpanUtf8ArrayFormatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;

        public TimeSpan[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class TimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan>, Byte>
    {
        public static readonly TimeSpanUtf8ListFormatter Default = new TimeSpanUtf8ListFormatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = TimeSpanUtf8Formatter.Default;

        public List<TimeSpan> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf16Formatter : IJsonFormatter<Guid, Char>
    {
        public static readonly GuidUtf16Formatter Default = new GuidUtf16Formatter();

        public Guid Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Guid();
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid value, int nestingLimit)
        {
            writer.WriteUtf16Guid(value);
        }
    }

    public sealed class NullableGuidUtf16Formatter : IJsonFormatter<Guid?, Char>
    {
        public static readonly NullableGuidUtf16Formatter Default = new NullableGuidUtf16Formatter();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;

        public Guid? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableGuidUtf16ArrayFormatter : IJsonFormatter<Guid?[], Char>
    {
        public static readonly NullableGuidUtf16ArrayFormatter Default = new NullableGuidUtf16ArrayFormatter();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = NullableGuidUtf16Formatter.Default;

        public Guid?[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class NullableGuidUtf16ListFormatter : IJsonFormatter<List<Guid?>, Char>
    {
        public static readonly NullableGuidUtf16ListFormatter Default = new NullableGuidUtf16ListFormatter();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = NullableGuidUtf16Formatter.Default;

        public List<Guid?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Guid?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf16ArrayFormatter : IJsonFormatter<Guid[], Char>
    {
        public static readonly GuidUtf16ArrayFormatter Default = new GuidUtf16ArrayFormatter();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;

        public Guid[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Guid[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf16ListFormatter : IJsonFormatter<List<Guid>, Char>
    {
        public static readonly GuidUtf16ListFormatter Default = new GuidUtf16ListFormatter();
        private static readonly GuidUtf16Formatter ElementFormatter = GuidUtf16Formatter.Default;

        public List<Guid> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Guid> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class GuidUtf8Formatter : IJsonFormatter<Guid, Byte>
    {
        public static readonly GuidUtf8Formatter Default = new GuidUtf8Formatter();

        public Guid Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Guid();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid value, int nestingLimit)
        {
            writer.WriteUtf8Guid(value);
        }
    }

    public sealed class NullableGuidUtf8Formatter : IJsonFormatter<Guid?, Byte>
    {
        public static readonly NullableGuidUtf8Formatter Default = new NullableGuidUtf8Formatter();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;

        public Guid? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid? value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault(), nestingLimit);
        }
    }

    public sealed class NullableGuidUtf8ArrayFormatter : IJsonFormatter<Guid?[], Byte>
    {
        public static readonly NullableGuidUtf8ArrayFormatter Default = new NullableGuidUtf8ArrayFormatter();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = NullableGuidUtf8Formatter.Default;

        public Guid?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid?[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class NullableGuidUtf8ListFormatter : IJsonFormatter<List<Guid?>, Byte>
    {
        public static readonly NullableGuidUtf8ListFormatter Default = new NullableGuidUtf8ListFormatter();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = NullableGuidUtf8Formatter.Default;

        public List<Guid?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid?> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf8ArrayFormatter : IJsonFormatter<Guid[], Byte>
    {
        public static readonly GuidUtf8ArrayFormatter Default = new GuidUtf8ArrayFormatter();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;

        public Guid[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Guid[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class GuidUtf8ListFormatter : IJsonFormatter<List<Guid>, Byte>
    {
        public static readonly GuidUtf8ListFormatter Default = new GuidUtf8ListFormatter();
        private static readonly GuidUtf8Formatter ElementFormatter = GuidUtf8Formatter.Default;

        public List<Guid> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class StringUtf16Formatter : IJsonFormatter<String, Char>
    {
        public static readonly StringUtf16Formatter Default = new StringUtf16Formatter();

        public String Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16String();
        }

        public void Serialize(ref JsonWriter<Char> writer, String value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16String(value);
        }
    }

    public sealed class StringUtf16ArrayFormatter : IJsonFormatter<String[], Char>
    {
        public static readonly StringUtf16ArrayFormatter Default = new StringUtf16ArrayFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;

        public String[] Deserialize(ref JsonReader<Char> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, String[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class StringUtf16ListFormatter : IJsonFormatter<List<String>, Char>
    {
        public static readonly StringUtf16ListFormatter Default = new StringUtf16ListFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = StringUtf16Formatter.Default;

        public List<String> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<String> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class StringUtf8Formatter : IJsonFormatter<String, Byte>
    {
        public static readonly StringUtf8Formatter Default = new StringUtf8Formatter();

        public String Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8String();
        }

        public void Serialize(ref JsonWriter<Byte> writer, String value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8String(value);
        }
    }

    public sealed class StringUtf8ArrayFormatter : IJsonFormatter<String[], Byte>
    {
        public static readonly StringUtf8ArrayFormatter Default = new StringUtf8ArrayFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;

        public String[] Deserialize(ref JsonReader<Byte> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, String[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class StringUtf8ListFormatter : IJsonFormatter<List<String>, Byte>
    {
        public static readonly StringUtf8ListFormatter Default = new StringUtf8ListFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = StringUtf8Formatter.Default;

        public List<String> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<String> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class VersionUtf16Formatter : IJsonFormatter<Version, Char>
    {
        public static readonly VersionUtf16Formatter Default = new VersionUtf16Formatter();

        public Version Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Version();
        }

        public void Serialize(ref JsonWriter<Char> writer, Version value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16Version(value);
        }
    }

    public sealed class VersionUtf16ArrayFormatter : IJsonFormatter<Version[], Char>
    {
        public static readonly VersionUtf16ArrayFormatter Default = new VersionUtf16ArrayFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;

        public Version[] Deserialize(ref JsonReader<Char> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Version[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class VersionUtf16ListFormatter : IJsonFormatter<List<Version>, Char>
    {
        public static readonly VersionUtf16ListFormatter Default = new VersionUtf16ListFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = VersionUtf16Formatter.Default;

        public List<Version> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Version> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class VersionUtf8Formatter : IJsonFormatter<Version, Byte>
    {
        public static readonly VersionUtf8Formatter Default = new VersionUtf8Formatter();

        public Version Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Version();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Version value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8Version(value);
        }
    }

    public sealed class VersionUtf8ArrayFormatter : IJsonFormatter<Version[], Byte>
    {
        public static readonly VersionUtf8ArrayFormatter Default = new VersionUtf8ArrayFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;

        public Version[] Deserialize(ref JsonReader<Byte> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Version[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class VersionUtf8ListFormatter : IJsonFormatter<List<Version>, Byte>
    {
        public static readonly VersionUtf8ListFormatter Default = new VersionUtf8ListFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = VersionUtf8Formatter.Default;

        public List<Version> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Version> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UriUtf16Formatter : IJsonFormatter<Uri, Char>
    {
        public static readonly UriUtf16Formatter Default = new UriUtf16Formatter();

        public Uri Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Uri();
        }

        public void Serialize(ref JsonWriter<Char> writer, Uri value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            writer.WriteUtf16Uri(value);
        }
    }

    public sealed class UriUtf16ArrayFormatter : IJsonFormatter<Uri[], Char>
    {
        public static readonly UriUtf16ArrayFormatter Default = new UriUtf16ArrayFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;

        public Uri[] Deserialize(ref JsonReader<Char> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Char> writer, Uri[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UriUtf16ListFormatter : IJsonFormatter<List<Uri>, Char>
    {
        public static readonly UriUtf16ListFormatter Default = new UriUtf16ListFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = UriUtf16Formatter.Default;

        public List<Uri> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Char> writer, List<Uri> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf16Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf16EndArray();
        }
    }

    public sealed class UriUtf8Formatter : IJsonFormatter<Uri, Byte>
    {
        public static readonly UriUtf8Formatter Default = new UriUtf8Formatter();

        public Uri Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Uri();
        }

        public void Serialize(ref JsonWriter<Byte> writer, Uri value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            writer.WriteUtf8Uri(value);
        }
    }

    public sealed class UriUtf8ArrayFormatter : IJsonFormatter<Uri[], Byte>
    {
        public static readonly UriUtf8ArrayFormatter Default = new UriUtf8ArrayFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;

        public Uri[] Deserialize(ref JsonReader<Byte> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }

        public void Serialize(ref JsonWriter<Byte> writer, Uri[] value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }

    public sealed class UriUtf8ListFormatter : IJsonFormatter<List<Uri>, Byte>
    {
        public static readonly UriUtf8ListFormatter Default = new UriUtf8ListFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = UriUtf8Formatter.Default;

        public List<Uri> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }

        public void Serialize(ref JsonWriter<Byte> writer, List<Uri> value, int nestingLimit)
        {
            if (value == null)
            {
                writer.WriteUtf8Null();
                return;
            }

            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0], nestingLimit);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i], nestingLimit);
                }
            }

            writer.WriteUtf8EndArray();
        }
    }
}