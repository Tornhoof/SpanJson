using System;
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters.Dynamic
{
    public partial class SpanJsonDynamicString<TSymbol> : SpanJsonDynamic<TSymbol> where TSymbol : struct
    {
        public static explicit operator Char(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Char), input.Symbols, out var value))
            {
                return (Char) value;
            }
            throw new InvalidCastException();
        }
	    public static explicit operator Char?(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Char?), input.Symbols, out var value))
            {
				return (Char?) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator DateTime(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(DateTime), input.Symbols, out var value))
            {
                return (DateTime) value;
            }
            throw new InvalidCastException();
        }
	    public static explicit operator DateTime?(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(DateTime?), input.Symbols, out var value))
            {
				return (DateTime?) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator DateTimeOffset(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(DateTimeOffset), input.Symbols, out var value))
            {
                return (DateTimeOffset) value;
            }
            throw new InvalidCastException();
        }
	    public static explicit operator DateTimeOffset?(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(DateTimeOffset?), input.Symbols, out var value))
            {
				return (DateTimeOffset?) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator TimeSpan(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(TimeSpan), input.Symbols, out var value))
            {
                return (TimeSpan) value;
            }
            throw new InvalidCastException();
        }
	    public static explicit operator TimeSpan?(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(TimeSpan?), input.Symbols, out var value))
            {
				return (TimeSpan?) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator Guid(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Guid), input.Symbols, out var value))
            {
                return (Guid) value;
            }
            throw new InvalidCastException();
        }
	    public static explicit operator Guid?(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Guid?), input.Symbols, out var value))
            {
				return (Guid?) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator String(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(String), input.Symbols, out var value))
            {
                return (String) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator Version(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Version), input.Symbols, out var value))
            {
                return (Version) value;
            }
            throw new InvalidCastException();
        }
        public static explicit operator Uri(SpanJsonDynamicString<TSymbol> input)
        {
            if (DynamicConverter.TryConvertTo(typeof(Uri), input.Symbols, out var value))
            {
                return (Uri) value;
            }
            throw new InvalidCastException();
        }
    }
}