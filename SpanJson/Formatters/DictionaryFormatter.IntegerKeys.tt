<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
    };
#>
	// Autogenerated
	// ReSharper disable BuiltInTypeReferenceStyle
	using System;
	using System.Collections.Generic;
    using System.Globalization;
	using System.Runtime.CompilerServices;

	namespace SpanJson.Formatters
	{
		public sealed partial class DictionaryFormatter<TDictionary, TWritableDictionary, TKey, TValue, TSymbol, TResolver> : BaseFormatter,
        IJsonFormatter<TDictionary, TSymbol>
        where TResolver : IJsonFormatterResolver<TSymbol, TResolver>, new() where TSymbol : struct where TDictionary : IEnumerable<KeyValuePair<TKey, TValue>>
		{
			private static NameToKeyDelegate BuildIntegerNameToKeyDelegate()
			{
<# foreach(var t in types) { #>
                if(typeof(TKey) == typeof(<#= t.Name #>))
				{
				    static TKey Parse<#= t.Name #>(string input)
					{
						var output = <#= t.Name #>.Parse(input, NumberStyles.Integer, CultureInfo.InvariantCulture);
						return Unsafe.As<<#= t.Name #>, TKey>(ref output);
					}
					return Parse<#= t.Name #>;
				}
<#}#>
				throw new NotSupportedException();
			}
			private static KeyToNameDelegate BuildIntegerKeyToNameDelegate()
			{
<# foreach(var t in types) { #>
                if(typeof(TKey) == typeof(<#= t.Name #>))
				{
				    static string Format<#= t.Name #>(TKey key)
					{
						var input = Unsafe.As<TKey, <#= t.Name #>>(ref key);
						return input.ToString(CultureInfo.InvariantCulture);
					}
					return Format<#= t.Name #>;
				}
<#}#>
				throw new NotSupportedException();
			}
		}
	}
